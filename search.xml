<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>『AGC 023C』Painting Machines</title>
      <link href="/2018/09/06/%E3%80%8EAGC%20023C%E3%80%8FPainting%20Machines/"/>
      <url>/2018/09/06/%E3%80%8EAGC%20023C%E3%80%8FPainting%20Machines/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-023C』Painting-Machines"><a href="#『AGC-023C』Painting-Machines" class="headerlink" title="『AGC 023C』Painting Machines"></a>『AGC 023C』Painting Machines</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Time limit : 2sec / Memory limit : 256MB</p><p>题意简述：</p><p>有$n$个方块排成一行，从左到右编号为$1$到$n$。最初所有的方块都是白色的。我们还有$N-1$台涂漆机，编号为$1$至$N-1$。当操作时，第$i$号机器把第$i$和$i+1$号方块染黑。</p><p>Snuke将逐个操作这些机器。他操作它们的顺序是$(1,2,…,N-1)$的一个排列$P$,这意味着第$i$个操作的机器是机器$P_i$。</p><p>排列$P$的得分被定义为当机器以$P$指定的顺序操作时，在所有方块第一次被涂成黑色之前操作的机器的数量。找出他所有可能排列的得分总和。因为这可能非常大，计算模$10^9+7$。</p><p><a href="https://agc023.contest.atcoder.jp/tasks/agc023_c" target="_blank" rel="noopener">door♂</a></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目可以转化为求 $\displaystyle \sum_{i = 0}^{N - 2} T(i)$</p><p>其中$T(i)$表示用了$i$次操作没有全部染黑的方案数</p><p>首先我们有$T(0) = (N - 1)!$ </p><p>然后分类讨论，一个是因为没用$N-1$而没有全部染黑的方案数是$\displaystyle \binom{N - 2}{i}i!$ </p><p>如果用了$N - 1$，那么方案是$\displaystyle \left (\binom{N - 2}{i - 1} - W(i - 1) \right )i!$ </p><p>$W(i)$表示用了一个$N - 1$号机器和其他$i$个机器，把所有方格染黑了的方案数</p><p>显然序列里会有$1$</p><p>把序列差分一下，会发现这个序列不是$1$就是$2$，也就是一堆$1$和一堆$2$的数目固定，一堆$1$和一堆$2$的和是$N - 2$，这是个二元一次方程，然后求出了$1$的个数和$2$的个数，就是个带重复元素的全排列，答案是 $\displaystyle\frac {(\text{num}_1 + \text{num}_2)! }{\text{num}_1 ! \text{num}_2 !}$ </p><p>由于其他$N - 1 - i$台机器随意排列，最后还要乘上$(N - i - 1)!$</p><p>Code:</p><div><div class="fold_hider"><div class="close hider_title">Click to show/hide the code</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll fac[MAXN], invfac[MAXN], ans;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fpow</span><span class="params">(<span class="keyword">const</span> ll&amp; x, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> ll res = <span class="number">1</span>, t = x;</span><br><span class="line"><span class="keyword">while</span> (c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c &amp; <span class="number">1</span>) res = res * t % MOD;</span><br><span class="line">t = t * t % MOD;</span><br><span class="line">c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fac[n] * invfac[m] % MOD * invfac[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">W</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = N - <span class="number">2</span> - k;</span><br><span class="line"><span class="keyword">int</span> y = k - x;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fac[k] * invfac[y] % MOD * invfac[x] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fac[<span class="number">0</span>] = invfac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">invfac[N] = fpow(fac[N], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">invfac[i] = invfac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % MOD;</span><br><span class="line">ans += fac[N - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; ++i)</span><br><span class="line">ans += (C(N - <span class="number">2</span>, i) + C(N - <span class="number">2</span>, i - <span class="number">1</span>) + MOD - W(i - <span class="number">1</span>))* fac[i] % MOD * fac[N - <span class="number">1</span> - i] % MOD, ans %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> 组合 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 023F』01 on Tree</title>
      <link href="/2018/09/06/%E3%80%8EAGC%20023F%E3%80%8F01%20on%20Tree/"/>
      <url>/2018/09/06/%E3%80%8EAGC%20023F%E3%80%8F01%20on%20Tree/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-023F』01-on-Tree"><a href="#『AGC-023F』01-on-Tree" class="headerlink" title="『AGC 023F』01 on Tree"></a>『AGC 023F』01 on Tree</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Time limit : 2sec / Memory limit : 256MB</p><p>题意简述：给你一棵由$0$和$1$组成的树（就是每个点的权值为$0$或者$1$），让你求该树的一种排列，使得每个节点的孩子都排在这个节点的后面，并且逆序对数量最小。</p><p><a href="https://agc023.contest.atcoder.jp/tasks/agc023_f" target="_blank" rel="noopener">door♂</a></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>把序列看成若干个集合的并</p><p>对于一个集合$C$记$C_0,C_1$为集合中$0,1$出现的次数</p><p>则我们考虑何时应该把这个集合$u$接在它父亲$p$的$01$集合后面</p><p>考虑如何选择这个集合$u$</p><p>我们知道，对于两个集合$m,n$，如果要使$m$放在$n$前面更优的话，必然满足$m_0&gt;n_0,m_1<n_1$，然后把这两个不等式左右两边都比一下，容易得到需要满足$\dfrac{m_0}{m_1}>\dfrac{n_0}{n_1}$</n_1$，然后把这两个不等式左右两边都比一下，容易得到需要满足$\dfrac{m_0}{m_1}></p><p>所以对于一个节点$u$，我们存储它的集合信息为$u_0,u_1$，因为只需要知道这两个东西就可以比较它们的偏序</p><p>于是我们就维护一个堆或者一个<code>set</code>，用来每次弹出最大的$\dfrac{u_0}{u_1}$的$u$，接在它的父亲节点的后面，然后把父亲节点和这个节点用一个并查集缩起来，相当于一个点</p><p>不停地取元素，直到堆为空。时间复杂度$O(\alpha n\log n)$，其中$\alpha$可以近似认为是一个常数。</p><p>Code:</p><div><div class="fold_hider"><div class="close hider_title">Click to show/hide the code</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll A[MAXN];</span><br><span class="line"><span class="built_in">map</span> &lt;ll, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t) &amp;&amp; t != <span class="string">'-'</span>) t = getchar();</span><br><span class="line"><span class="keyword">if</span> (t == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">y = <span class="number">-1</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">x *= y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(ll &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> ll y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t) &amp;&amp; t != <span class="string">'-'</span>) t = getchar();</span><br><span class="line"><span class="keyword">if</span> (t == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">y = <span class="number">-1</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">x *= y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_read(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) _read(A[i]);</span><br><span class="line">M[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A[i] += A[i - <span class="number">1</span>];</span><br><span class="line">ans += M[A[i]];</span><br><span class="line">M[A[i]] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> Heap </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 023A』Zero-Sum Ranges</title>
      <link href="/2018/09/06/%E3%80%8EAGC%20023A%E3%80%8FZero-Sum%20Ranges/"/>
      <url>/2018/09/06/%E3%80%8EAGC%20023A%E3%80%8FZero-Sum%20Ranges/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-023A』Zero-Sum-Ranges"><a href="#『AGC-023A』Zero-Sum-Ranges" class="headerlink" title="『AGC 023A』Zero-Sum Ranges"></a>『AGC 023A』Zero-Sum Ranges</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Time limit : 2sec / Memory limit : 256MB</p><p>我们有一个整数序列$A$，其长度是$N$</p><p>请找出其总和为$0$的$A$的非空邻接子序列的数目。请注意，我们正在计算取出子序列的方法。也就是说，即使某些两个子序列的内容相同，如果它们取自不同的位置，则对它们进行单独计数。</p><p><a href="https://agc023.contest.atcoder.jp/tasks/agc023_a" target="_blank" rel="noopener">door♂</a></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>$n^2$的算法会超时</li></ul><p>首先看样例</p><div class="table-container"><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>数字</td><td>1</td><td>3</td><td>-4</td><td>2</td><td>2</td><td>-2</td></tr><tr><td>前缀和</td><td>1</td><td>4</td><td>0</td><td>2</td><td>4</td><td>2</td></tr></tbody></table></div><p>我们可以发现<strong>相同的两个数之间之间经过的数</strong>的和一定是$0$；<br>例如第一个$4 $和第二个$4$ 之间是 $-4 + 2 +2=0$所以我们发现规律：</p><ul><li>只要找到相同的数的个数让他们之间两两连接就是个数<br>如果和为$0$代表从第一个开始到它的和就是$0$所以要额外加上$0$的个数</li></ul><p>懒得离散化就用<code>map</code>，反正能过233</p><p>Code:</p><div><div class="fold_hider"><div class="close hider_title">Click to show/hide the code</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll A[MAXN];</span><br><span class="line"><span class="built_in">map</span> &lt;ll, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t) &amp;&amp; t != <span class="string">'-'</span>) t = getchar();</span><br><span class="line"><span class="keyword">if</span> (t == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">y = <span class="number">-1</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">x *= y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(ll &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> ll y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t) &amp;&amp; t != <span class="string">'-'</span>) t = getchar();</span><br><span class="line"><span class="keyword">if</span> (t == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">y = <span class="number">-1</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">x *= y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_read(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) _read(A[i]);</span><br><span class="line">M[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A[i] += A[i - <span class="number">1</span>];</span><br><span class="line">ans += M[A[i]];</span><br><span class="line">M[A[i]] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Atcoder </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OI代码模板计划 - 后缀数组</title>
      <link href="/2018/09/03/%5BOI%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E8%AE%A1%E5%88%92%5D%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2018/09/03/%5BOI%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E8%AE%A1%E5%88%92%5D%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="OI代码模板计划-后缀数组"><a href="#OI代码模板计划-后缀数组" class="headerlink" title="[OI代码模板计划] 后缀数组"></a>[OI代码模板计划] 后缀数组</h1><p>代码：后缀排序</p><p>读入一个长度为 $n$ 的由小写英文字母组成的字符串，请把这个字符串的所有非空后缀按字典序从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为 $1$ 到 $n$。</p><p>除此之外为了进一步证明你确实有给后缀排序的超能力，请另外输出 $n−1$ 个整数分别表示排序后相邻后缀的最长公共前缀的长度。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000 + 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> y[MAXN], x[MAXN], c[MAXN], sa[MAXN], h[MAXN], rk[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)</span><br><span class="line">        print(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getsa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">++c[x[i] = s[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; ++i)</span><br><span class="line">c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">sa[c[x[i]]--] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - k + <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">y[++num] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line"><span class="keyword">if</span> (sa[i] &gt; k)</span><br><span class="line">y[++num] = sa[i] - k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) ++c[x[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; ++i)</span><br><span class="line">c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;</span><br><span class="line">swap(x, y);</span><br><span class="line">x[sa[<span class="number">1</span>]] = <span class="number">1</span>;num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num;</span><br><span class="line"><span class="keyword">if</span> (num == N) <span class="keyword">break</span>;</span><br><span class="line">M = num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">print(sa[i]), <span class="built_in">putchar</span>(<span class="string">' '</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">geth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">rk[sa[i]] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k) k--;</span><br><span class="line"><span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (j + k &lt;= N &amp;&amp; i + k &lt;= N &amp;&amp; s[i + k] == s[j + k]) ++k;</span><br><span class="line">h[rk[i]] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">print(h[i]), <span class="built_in">putchar</span>(<span class="string">' '</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **Argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">gets(s+<span class="number">1</span>);</span><br><span class="line">    N = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    M = <span class="number">122</span>;</span><br><span class="line">    getsa();</span><br><span class="line">    geth();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> strings </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『JZOJ 4669』【NOIP2016提高A组模拟7.19】弄提纲</title>
      <link href="/2018/09/02/%E3%80%8EJZOJ-4669%E3%80%8F%E3%80%90NOIP2016%E6%8F%90%E9%AB%98A%E7%BB%84%E6%A8%A1%E6%8B%9F7.19%E3%80%91%E5%BC%84%E6%8F%90%E7%BA%B2/"/>
      <url>/2018/09/02/%E3%80%8EJZOJ-4669%E3%80%8F%E3%80%90NOIP2016%E6%8F%90%E9%AB%98A%E7%BB%84%E6%A8%A1%E6%8B%9F7.19%E3%80%91%E5%BC%84%E6%8F%90%E7%BA%B2/</url>
      <content type="html"><![CDATA[<h1 id="『JZOJ-4669』【NOIP2016提高A组模拟7-19】弄提纲"><a href="#『JZOJ-4669』【NOIP2016提高A组模拟7-19】弄提纲" class="headerlink" title="『JZOJ 4669』【NOIP2016提高A组模拟7.19】弄提纲"></a>『JZOJ 4669』【NOIP2016提高A组模拟7.19】弄提纲</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p><a href="https://jzoj.net/senior/#main/show/4669" target="_blank" rel="noopener">link</a></p><p><img src="\images\jzoj4669.jpg" alt="jzoj4669"></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>KMP处理出$P_i​$（就是所谓的next数组）</p><p>我们可以把 $P_i$看成：点$ i$ 的父亲是$P_i$。这样实际上$P$ 数组的存在就构成了一棵树。<br>然后现在问题变成了给两个点 $x$ 和$ y$，求他们的$\rm lca$ 以及$\rm lca$ 的深度，然后用倍增求$\rm lca$，$\rm rmq$<br>求$\rm lca$，或$ \rm tarjan $求$\rm lca$等都是可以的。时间复杂度 $O(n)$或 $O(n\ log\ n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poi</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">poi *nt;</span><br><span class="line">&#125; *a[MAXN];</span><br><span class="line"><span class="keyword">int</span> i, n, len, l, r, s, ans, p[MAXN], dep[MAXN], fa[MAXN][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> st[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">poi *p = <span class="keyword">new</span> poi;</span><br><span class="line">p-&gt;x = y;</span><br><span class="line">p-&gt;nt = a[x];</span><br><span class="line">a[x] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">poi *p = <span class="keyword">new</span> poi;</span><br><span class="line"><span class="keyword">for</span> (p = a[x]; p; p = p-&gt;nt)</span><br><span class="line"><span class="keyword">if</span> (p-&gt;x != fa[x][<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">dep[p-&gt;x] = dep[x] + <span class="number">1</span>;</span><br><span class="line">fa[p-&gt;x][<span class="number">0</span>] = x;</span><br><span class="line">dfs(p-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">len = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; st[i] != st[j + <span class="number">1</span>]) j = p[j];</span><br><span class="line"><span class="keyword">if</span> (st[i] == st[j + <span class="number">1</span>]) j++;</span><br><span class="line">p[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) link(i, p[i]), link(p[i], i);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getlca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[y] &gt; dep[x]) swap(x, y);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> d = dep[x] - dep[y];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (d &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">x = fa[x][i];</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">26</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">x = fa[x][i], y = fa[y][i];</span><br><span class="line"><span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">gets(st + <span class="number">1</span>);</span><br><span class="line">pre();</span><br><span class="line">_read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_read(l), _read(r);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> lca = getlca(l, r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>, dep[lca], lca);<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> strings </tag>
            
            <tag> LCA </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>窗函数</title>
      <link href="/2018/09/01/%E7%AA%97%E5%87%BD%E6%95%B0/"/>
      <url>/2018/09/01/%E7%AA%97%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="窗函数"><a href="#窗函数" class="headerlink" title="窗函数"></a>窗函数</h1><p>实在是无聊（主要是因为llc神犇在上学期提过窗函数，然而我当时并看不懂，这次把坑填上…)…然后看了几篇关于窗函数的资料…本文就权当抛砖引玉吧</p><hr><p>数字信号处理的主要数学工具是傅里叶变换，而傅里叶变换是研究<strong>整个</strong>时间域和频率域的关系，当运用计算机实现测试信号处理时，不可能对无限长的信号进行测量和运算，而是取其有限的时间片段进行分析。</p><ul><li>从信号中截取一个时间片段，<del>然后用截取的信号时间片段进行<strong>周期延拓</strong>处理，得到虚拟的无限长信号，再进行傅里叶变换和相关分析。</del>无限长信号被截断后，其频谱发生了<strong>畸变</strong>，我们称为频谱<strong>能量泄漏</strong>，为了减少<strong>频谱泄漏</strong>，可采用不同的截取函数对信号进行截断，截断函数称为<strong>窗函数</strong>，简称为窗。</li></ul><a id="more"></a><p>据学信号学的大佬所说，杠掉的地方有些问题。所以这里展示一下大佬的笔记吧，就不重新表述了（公式太多QwQ）</p><p><img src="/images/windownotes1.jpg" alt=""></p><p><img src="/images/windownotes2.jpg" alt=""></p><p><img src="/images/windownotes3.jpg" alt=""></p><p>顺便膜一下dalao，看不懂的孩纸还是继续看下文吧</p><h2 id="加窗的目的"><a href="#加窗的目的" class="headerlink" title="加窗的目的"></a>加窗的目的</h2><p>其实上文已经讲过了，计算机不可能对无限长的信号进行测量和运算。每次$\rm FFT$只能对有限长度的时域数据进行变换，因此需要对时域信号进行信号截断，<strong>即使是周期信号，如果截断的时间长度不是周期的整数倍(整周期截断)，那么截取后的信号也会存在频谱泄漏</strong>，为了将这个泄漏误差减少到最小程度(不是消除)，我们需要使用窗函数。加窗主要是为了使时域信号似乎更好的满足$\rm FFT$处理的周期性要求，减少泄漏。</p><p><img src="/images/window1.jpg" alt="整周期截断、非整周期截断及加窗后的频谱"></p><p>从上图我们得出，如果是整周期截断，则$\rm FFT$频谱为单一谱线。若为非整周期截断，则频谱出现拖尾，也就是说泄漏很严重。为了减少泄漏，给信号施加一个窗函数，原始截断后的信号与这个窗函数相乘之后得到的信号为最右侧的信号。可以看出，此时信号的起始时刻和结束时刻幅值都为$0$，也就是说在这个时间长度内，信号为周期信号，但是只有一个周期，对这个信号做$\rm FFT$，相比之前未加窗的频谱，泄漏已<strong>明显改善，但并未完全消除</strong>，因此窗函数只能<strong>减少泄漏，不能消除泄漏</strong>。</p><h2 id="窗函数的形象描述"><a href="#窗函数的形象描述" class="headerlink" title="窗函数的形象描述"></a>窗函数的形象描述</h2><p>信号截断时，只能截取一定长度，哪怕原始信号是无限长，就好像是用一个<em>窗</em>(确切来说更像一个<em>框</em>)去做这样的截取。如下Pic.1所示，原始信号是周期信号，时间很长，截取时用红色的<em>窗</em>去截取这个周期信号，截取得到的信号如Pic.2所示。</p><p><img src="/images/window2.png" alt="Pic.1 Origin Signal"></p><p><img src="/images/window3.png" alt="Pic.2 Signal after Time Window Truncation"></p><p>这个“窗”是一个单位权重的加权函数，成为<em>矩形窗</em>。这个<em>窗</em>外的信号是看不到的，就如同透过窗户看外面的世界，你只能看到在窗内的景色。这就是为什么这样的加权函数被成为窗函数的真正原因（其实还是很形象的）。</p><p>　　Pic.2中用于截取信号的时域截取函数称为窗函数，它是一种<strong>加权函数</strong>，不同窗的<strong>加权</strong>是不一样的，也就是说，可以用不同的窗函数来做信号截断。常用的窗函数有矩形窗、汉宁窗、平顶窗和指数窗等。</p><p>加窗在时域上表现的是<strong>点乘</strong>，因此在频域上则表现为<strong>卷积</strong>。卷积可以被看成是一个平滑的过程。这个平滑过程可以被看出是由一组具有特定函数形状的滤波器，因此，原始信号中在某一频率点上的能量会结合滤波器的形状表现出来，从而减小泄漏。基于这个原理，人们通常在时域上直接加窗。</p><h2 id="窗函数的时频域特征"><a href="#窗函数的时频域特征" class="headerlink" title="窗函数的时频域特征"></a>窗函数的时频域特征</h2><p><img src="\images\1535810012918.png" alt="信号加窗"></p><p><img src="/images/w4.jpg" alt="常用窗函数"> </p><p>上面那幅图当中，较为平缓的曲线为<em>时域形状</em>，有若干个瓣是<em>频域特征</em></p><p>窗函数的典型频谱特征如下图所示：</p><p><img src="\images\1535810209279.png" alt="窗函数的典型频谱特征"></p><h2 id="窗函数的选择"><a href="#窗函数的选择" class="headerlink" title="窗函数的选择"></a>窗函数的选择</h2><p>在上面的常用窗函数一图当中，矩形窗主瓣窄，旁瓣大，频率识别精度最高，幅值识别精度最低，如果仅要求精确读出主瓣频率，而不考虑幅值精度，则可选用矩形窗，例如测量物体的自振频率等；布莱克曼窗主瓣宽，旁瓣小，频率识别精度最低，但幅值识别精度最高；如果分析窄带信号，且有较强的干扰噪声，则应选用旁瓣幅度小的窗函数，如汉宁窗、三角窗等；对于随时间按指数衰减的函数，可采用指数窗来提高信噪比。  如果被测信号是随机或者未知的，或者是一般使用者对窗函数不大了解，要求也不是特别高时，可以选择汉宁窗，因为它的泄漏、波动都较小，并且选择性也较高。但在用于校准时选用平顶窗较好，因为它的通带波动非常小，幅度误差也较小。 </p><p>看一下各种窗函数的对比（好吧其实我不是很懂这个地方，还是需要学习）：</p><div class="table-container"><table><thead><tr><th>名称</th><th>表达式</th></tr></thead><tbody><tr><td>矩形窗</td><td>${\displaystyle w(n)=1}$</td></tr><tr><td>汉宁窗</td><td>${\displaystyle w(n)=0.5\;\left(1-\cos \left({\frac {2\pi n}{N-1}}\right)\right)}$</td></tr><tr><td>平顶窗</td><td>${\displaystyle w(n)=a_{0}-a_{1}\cos \left({\frac {2\pi n}{N-1}}\right)+a_{2}\cos \left({\frac {4\pi n}{N-1}}\right)-a_{3}\cos \left({\frac {6\pi n}{N-1}}\right)+a_{4}\cos \left({\frac {8\pi n}{N-1}}\right)}\\a_{0}=1;\quad a_{1}=1.93;\quad a_{2}=1.29;\quad a_{3}=0.388;\quad a_{4}=0.028$</td></tr><tr><td>海明窗</td><td>${\displaystyle w(n)=0.53836-0.46164\;\cos \left({\frac {2\pi n}{N-1}}\right)}$</td></tr><tr><td>Kaiser窗</td><td>${\displaystyle w(n)={\frac {I_{0}{\Bigg (}\pi \alpha {\sqrt {1-( {\begin{matrix}{\frac {2n}{N-1} }\end{matrix} }-1)^{2} } }{\Bigg ) } }{I_{0}(\pi \alpha ) } } } $</td></tr><tr><td>布莱克曼窗</td><td>${\displaystyle w(n)=a_{0}-a_{1}\cos \left({\frac {2\pi n}{N-1}}\right)+a_{2}\cos \left({\frac {4\pi n}{N-1}}\right) } \\  a_{0}={\frac {1-\alpha }{2}};\quad a_{1}={\frac {1}{2}};\quad a_{2}={\frac {\alpha }{2} }$</td></tr><tr><td>高斯窗</td><td>${\displaystyle w(n)=e^{-{\frac {1}{2}}\left({\frac {n-(N-1)/2}{\sigma (N-1)/2}}\right)^{2}}}$</td></tr><tr><td>三角窗</td><td>$\displaystyle w(n)=1 -  \text{abs}\left ( {\frac{n-{\frac {N-1}{2} } }{\frac{L}{2} } } \right )$</td></tr><tr><td>Chebyshev窗</td><td>${\displaystyle {\begin{aligned} W_{0}(k)&amp;={\frac {\cos\{N\cos ^{-1}[\beta \cos({\frac {\pi k}{N} } ) ] \} } {\cosh[N\cosh ^{-1}(\beta ) ] } } \\\beta &amp;=\cosh[ {\frac {1}{N} }\cosh ^{-1}(10^{\alpha } ) ],\end{aligned} } }$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>名称</th><th>特点</th><th>应用</th></tr></thead><tbody><tr><td>矩形窗</td><td>矩形窗使用最多，习惯上不加窗就是使信号通过了矩形窗。这种窗的有点是主瓣集中，缺点是旁瓣比较高，并且有负旁瓣，导致变换中带进了<strong>高频干扰</strong>和泄露，甚至出现<strong>负谱现象</strong>。频率识别<strong>精度最高</strong>，幅值识别<strong>精度最低</strong>，所以矩形窗并不是非常理想</td><td>仅要求精确读出主瓣频率，而不考虑幅值精度，则可以使用矩形窗，例如测量物体的自振频率和阶次分析</td></tr><tr><td>汉宁窗</td><td>又称升余弦窗，可以看作是$3$个矩形时间窗的频谱之和，或者说是$3$个$\text{sinc}(T)$型函数之和。汉宁窗主瓣加宽并降低，旁瓣则显著减小，从减小泄漏观点出发，汉宁窗优于矩形窗．但汉宁窗主瓣加宽，相当于分析带宽加宽，频率分辨力下降。</td><td>如果测试信号有多个频率分量，频谱表现的十分复杂，且测试的目的更多关注频率点而并非能量的大小，需要选择汉宁窗。如果被测信号是随机的或者未知的也要选择汉宁窗</td></tr><tr><td>平顶窗</td><td>平顶窗在频域时的表现就像它的名称一样有非常小的通带波动</td><td>由于在<strong>幅度</strong>上有较小的误差，这个窗可以用在<strong>校准</strong>上</td></tr><tr><td>海明窗</td><td>也是余弦窗，又称改进的升余弦窗，<strong>加权系数不同</strong>，使得旁瓣达到更小，但旁瓣衰减速度比汉宁窗更慢</td><td>和汉宁窗类似</td></tr><tr><td>Kaiser窗</td><td>定义了一组可调的由零阶Bessel函数构成的窗函数，通过调整参数$\beta$，可以在主瓣宽度和旁瓣衰减之间自由选择它们的比重。对于某一长度的Kaiser窗，给定$\beta$，则旁瓣高度固定。</td><td>最好的旁瓣抑制性能</td></tr><tr><td>布莱克曼窗</td><td>二阶升余弦窗，主瓣宽，旁瓣比较低，但等效噪声贷款比汉宁窗要大一些，波动却小一些。频率识别<strong>精度最低</strong>，值识别<strong>精度最高</strong>（和矩形窗刚好相反），有更好的选择性</td><td>用来检测两个频率相近幅度不同的信号</td></tr><tr><td>高斯窗</td><td>是一种指数窗。高斯窗谱无负的旁瓣，第一旁瓣衰减达$-55\rm dB$。高斯富谱的主瓣较宽，所以频率分辨力低。</td><td>截短一些非周期信号，如指数衰减信号等。</td></tr><tr><td>三角窗</td><td>是幂窗的一次方形式。与矩形窗比较，主瓣宽约等于矩形窗的两倍，但旁瓣小，而且没有负旁瓣。</td><td>分析有较强干扰噪声的窄带信号（也可用汉宁窗）</td></tr><tr><td>Chebyshev窗</td><td>在给定旁瓣高度下，Chebyshev窗的主瓣宽度最小，具有等波动性，就是说其所有的旁瓣都有相等的高度</td></tr></tbody></table></div><h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h3 id="加窗是为了截取信号的某一截-如果采集了32K的点，点数不是已经有限了？"><a href="#加窗是为了截取信号的某一截-如果采集了32K的点，点数不是已经有限了？" class="headerlink" title="加窗是为了截取信号的某一截?如果采集了32K的点，点数不是已经有限了？"></a>加窗是为了截取信号的某一截?如果采集了32K的点，点数不是已经有限了？</h3><blockquote><p>并不是。</p><p>FFT算法基于你采样的信号是<strong>无限长的周期的</strong>信号，也就是你32k的数据会被认为是<strong>不断重复</strong>的，32k最后一个点之后又连到第一个点，这样不断重复，这样就有可能出现波形断开的情况，这个不连续会导致FFT结果出现频谱泄漏现象， 但是你的实际信号是连续的，所以加窗的目的就是让不太连续的地方（最后一个点和第一个的连接处）看上去平滑了，没有原来那么明显的突变了</p></blockquote><h3 id="原始数据加窗之后，数据都变了，FFT后的频谱为什么还能作为参考？"><a href="#原始数据加窗之后，数据都变了，FFT后的频谱为什么还能作为参考？" class="headerlink" title="原始数据加窗之后，数据都变了，FFT后的频谱为什么还能作为参考？"></a>原始数据加窗之后，数据都变了，FFT后的频谱为什么还能作为参考？</h3><blockquote><p>这个问题其实非常的奇怪…</p><p>窗函数加在时间域上，相当于和信号做乘法，所以频域上是卷积，这就是傅里叶变换的性质</p><p>窗函数不是周期函数。它的频率可以看成无穷小，傅里叶变换从另一个角度也可以看成傅里叶级数当T趋于无穷的极限。</p><p>加完窗到底能改进些什么？当然是减少能量泄露。因为不加窗无穷序列，计算机没法做FFT，加窗是迫不得已。有的时候你想了解某一段的频率特性，也需要加窗。加窗的影响就是那个卷积变换，自己要加入幅值修正。</p></blockquote><h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>Related</h2><p>[1] WIKIPEDIA, <a href="https://en.wikipedia.org/wiki/Window_function" target="_blank" rel="noopener">Window Function</a></p><p>[2] VFE, <a href="https://www.vfe.cc/NewsDetail-2239.aspx" target="_blank" rel="noopener">通俗地理解窗函数</a></p><p>[3] 雪韵凌枫, <a href="https://blog.csdn.net/u013360881/article/details/77714168" target="_blank" rel="noopener">数字信号分析——窗函数</a></p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 物理 </tag>
            
            <tag> 信号学 </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础乐理与数学（二）</title>
      <link href="/2018/09/01/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/09/01/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="基础乐理与数学（二）"><a href="#基础乐理与数学（二）" class="headerlink" title="基础乐理与数学（二）"></a>基础乐理与数学（二）</h1><h2 id="Read-before"><a href="#Read-before" class="headerlink" title="Read before"></a>Read before</h2><p>阅读本文之前，您先需要阅读<a href="https://skyofwar.xyz/2018/08/31/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/">基础乐理与数学（一）</a></p><hr><h2 id="五线谱进阶"><a href="#五线谱进阶" class="headerlink" title="五线谱进阶"></a>五线谱进阶</h2><h3 id="五线谱中的相对音程"><a href="#五线谱中的相对音程" class="headerlink" title="五线谱中的相对音程"></a>五线谱中的相对音程</h3><p>上一讲我们已经知道了高音五线谱中，第二间的$A$的音高定为$440\rm Hz$，很自然地引出了一个问题，我们如何来确定其它音的音高？下面将会按照<em>十二平均律</em>的法则在五线谱中建立相对音高系统。</p><p><img src="/images/25170257-974e3ba93c4c4ba2927c012168690e4e.png" width="25%" height="25%"></p><a id="more"></a><p>上图是一个放大的最简单的高音谱，可以看到第一线上的音名是$E$，第一间的音名是$F$，其它以此类推。右侧的<strong>全</strong>和<strong>半</strong>表示相邻两个音符之间的音程是全音还是半音。至于为什么是这样规定的，会在下一节进一步展开。确定了音符之间的相对音程，并确定了一个基准音高$A$，我们就可以开始推算所有其它单音的频率了。</p><p>首先为了方便的表示众多音符，下文将使用科学记音法（详见<a href="http://en.wikipedia.org/wiki/Scientific_pitch_notation" target="_blank" rel="noopener">维基百科</a>）来表示所有的音符，即两个字符表示一个音：$XN$。其中$X$为音名，可以是$\{C, D, E, F, G, A, B\}$中的任意一个；$N$为该音的序号，从$0$开始由低到高编号。$N$每增加$1$，音的频率就翻倍，并规定第$C4$位于高音五线谱的下加一线。根据科学音调记号法，高音谱下加一线上的$C$记作$C4$，往高依次是$D4,E4,F4……$往低依次是$B3,A3,G3……$。所有的$C$音在五线谱上标记，如下图所示。</p><p><img src="/images/26120954-72297034a69245dfbdb70ece3f2c5bb0.png" alt="五线谱上所有C音的音符"></p><p>比$A4$低纯八度的音符是$A3$，其频率为A4频率的一半，即$220\rm Hz$，比$A4$高纯八度的音符是$A5$，频率为$A4$频率的二倍，即$880$。$A0$到$A7$间所有$A$音的频率见下表：</p><div class="table-container"><table><thead><tr><th>基准音名</th><th>A0</th><th>A1</th><th>A2</th><th>A3</th><th>A4</th><th>A5</th><th>A6</th><th>A7</th></tr></thead><tbody><tr><td>频率$(\rm Hz)$</td><td>$27.5$</td><td>$55$</td><td>$110$</td><td>$220$</td><td>$440$</td><td>$880$</td><td>$1760$</td><td>$3520$</td></tr></tbody></table></div><p>要计算其它音符$XN$的频率$f_X$，则应以$XN$下方的第一个$A$音$AN’$的频率$f_A$作为基准，然后算出$XN$与$AN’$之间的音数$t$，那么$XN$的频率为：$\displaystyle f_X=f_A\times 2^\frac{2t}{12}=f_A\times 2^\frac{t}{6}$。例如，由于第三间的$C$音（即$C5$）与其下方第一个$A$音，即$A4$之间的音程是小三度，音数$t=1.5$，因此$C5$的频率为：$\displaystyle 440\times 2^\frac{1.5}{6}\approx 523.25113\text{Hz}$。当然，也可通过纯八度音程的倍率关系计算，比如$C4$的频率为$C5$的$\dfrac{1}{2}$，<strong>约为</strong>$261.62557 \rm Hz$。</p><h3 id="升降记号"><a href="#升降记号" class="headerlink" title="升降记号"></a>升降记号</h3><p>五线谱中，音符的后面可以添加升降标记，表示该音符升高半音或降低半音。升号为#，降号为b。显然，有两个音是没必要升的：$E$升半音就是$F$，$B$升半音就是$C$，而这就是钢琴键盘布局形成的原因。如下图所示：</p><p><img src="/images/26125450-481027d0466742ec8afdab21d041eece.gif" alt="钢琴键盘中部分键位的音名(下面是白键音名，上面是黑键音名)"></p><p>钢琴上的黑键比左边的白键高半音（也可以说是比右边的白键低半音），因此白键$B$和$E$的右边就没有黑键。此外，所有的降音都可以由另一些音的升音代替，比如$B$b就是$A$#，$G$b就是$F$#。那既然如此，为什么不用升号代替全部的降号呢？原因就是为了可读性，<strong>正如写代码时不能为了减少代码量就把所有的if语句都换成三目运算符</strong>。</p><p>如果一段谱子中的某个音符几乎都要升半音或降半音处理，那就可以在高音谱号的右侧，这个音符所在的一条线或一个间上标记升降号。</p><p><img src="/images/25174705-42e729ae191c44fda5db92613606d85e.png" alt="肖邦《练习曲 Op.25》第3首选段"></p><p>在上图乐谱中，第三线上标记了一个降号b，表示这个谱子里的所有$B$音都需降半音，除非另外在个别音符上标记升降或还原记号。音符被升降半音后的频率可根据之前学过的相邻音符之间的频率倍数关系计算。升高半音后的频率为原频率的$\sqrt[12]{2}$倍，降低半音后的频率为原频率的$\dfrac{1}{\sqrt[12]{2}}$倍。比如$C5$升高半音的频率即为$523.25113\times \sqrt[12]{2}\approx 554.3653\text{Hz}$。</p><h3 id="双音谱"><a href="#双音谱" class="headerlink" title="双音谱"></a>双音谱</h3><p><img src="/images/25153446-2580394f652f4a989ab02f3525b37455.png" alt="肖邦《C大调练习曲》选段"></p><p>是一个钢琴谱，这下我们终于见到了高音谱号和低音谱号并存的样子了。标有高音谱号的上面一排是<strong>高音谱</strong>，标有低音谱号的下面一排是<strong>低音谱</strong>，它们分别对应钢琴健盘上不同的键区。低音谱的<em>线</em>和$间$所对应的音符与高音谱不同，如下图：</p><p><img src="/images/25160225-591cdab1bdd64f5587c4880e5f0994cc.gif" alt="低音谱各音符及其音名"></p><p>低音谱实际上是和高音谱互相连接的，音名也没有那么难记，中间刚好只隔了一条加线。高音谱的下加一线就是低音谱的上加一线，而这条线上的音就是中央$C$，即$C4$。和高音谱号类似，低音谱号的圆心标记的是$F3$在谱中的位置，即第四线上。</p><p>低音谱中各音的频率计算与高音谱是相同的，只要搞清音程关系，从基准音推算即可。比如在前面的钢琴谱中可以看到低音谱的最左端有两个$C$（是用圆圈表示），一个是第二间的$C3$；另一个是下加二线上的$C2$。$C3$和$C2$的频率分别为$C4$频率的$\dfrac{1}{4}$和$\dfrac{1}{8}$，而$C4$的频率在前面已经计算过了。</p><p>利用上面的知识，你已经可以计算任何一个五线谱中每个音的频率了，接下来我们介绍对一些特别的频率进行合成的问题——<strong>和声</strong>。</p><h2 id="和声"><a href="#和声" class="headerlink" title="和声"></a>和声</h2><p><strong>和声</strong>，是指由超过一个单音所组合而成的声音。你可能会发现，和声的定义与拍音的定义是非常<strong>相似</strong>的。的确如此，<em>所有的拍音都是和声，但和声不一定会产生拍音</em>。</p><p>具体区别：</p><ul><li>人耳可以听到的声波频率范围大约为$20\rm Hz$到$20000\rm Hz$，如果和声产生的频率超过这个范围，通常就不能称之为拍音了。</li><li>不同的乐器发出的单音进行叠加也可以称为和声，这也不是拍音。拍音要求所有单音同时发出，而和声则无此要求，只要一个音在另一个音结束之前发出，它们交叠的部分就形成了和声。</li></ul><p>在西方古典音乐理论中，和声主要研究两个单音构成的和声，三个或以上单音构成的和声一般称为和弦，我们放在下一节讨论。在一个纯八度范围内，两个单音的和声一共有$12$种，即与$12$种音程相对应。在钢琴键盘上以中央$C$键，即$C4$为准，请试听一下$C4$分别与$D4$、$E4$、$F4$、$G4$、$A4$、$B4$以及$C5$键同时按下的和声效果。</p><p>听过以后，发现某些和声比较悦耳，而某些则比较难听。</p><p>比如$C4$和$C5$同时按下（纯八度音程）的和声就婉如只有一个音，十分融洽；而$C4$和$D4$同时按下（小二度音程）就使人非常难受。这是为什么呢？</p><p><img src="/images/25204137-cf3abc76aff3462c80256f4ae663cead.jpg" alt="钢琴键盘与五线谱对照图"></p><p>就是因为<strong>拍音</strong>！</p><p>相邻两个音之间的频率比为$\sqrt[12]{2}\approx 1.059463$，我们将这个数记为$p$，那么各音程的频率比（即相距某个音程的低音比高音）可由其音数$t$按公式：$\dfrac{1}{ (2t) ^ p }$算得。由于除纯八度外的所有音程的频率比均为无理数，因此他们的拍音的频率只能按他们频率的近似整数比来计算，详见第一讲第三节。计算近似整数比的数学过程是比较复杂的，这里篇幅有限，不做进一步的讨论。接下来我们分别换算一下$12$个音程的频率比。</p><div class="table-container"><table><thead><tr><th>音程</th><th>近似频率比</th><th>近似整数比</th><th>最小公倍数</th></tr></thead><tbody><tr><td>小二度</td><td>$1:1.06$</td><td>$15:16$</td><td>$240$</td></tr><tr><td>大二度</td><td>$1:1.12$</td><td>$8:9$</td><td>$72$</td></tr><tr><td>小三度</td><td>$1:1.19$</td><td>$5:6$</td><td>$30$</td></tr><tr><td>大三度</td><td>$1:1.26$</td><td>$4:5$</td><td>$20$</td></tr><tr><td>纯四度</td><td>$1:1.34$</td><td>$3:4$</td><td>$12$</td></tr><tr><td>三全音</td><td>$1:1.41$</td><td>$7:10$</td><td>$70$</td></tr><tr><td>纯五度</td><td>$1:1.50$</td><td>$2:3$</td><td>$6$</td></tr><tr><td>小六度</td><td>$1:1.59$</td><td>$5:8$</td><td>$40$</td></tr><tr><td>大六度</td><td>$1:1.68$</td><td>$3:5$</td><td>$15$</td></tr><tr><td>小七度</td><td>$1:1.78$</td><td>$5:9$</td><td>$45$</td></tr><tr><td>大七度</td><td>$1:1.89$</td><td>$8:15$</td><td>$120$</td></tr><tr><td>纯八度</td><td>$1:2$</td><td>$1:2$</td><td>$2$</td></tr></tbody></table></div><p>按近似整数比的最小公倍数排序，可以得到如下<strong>和声序列</strong>：</p><p>纯八度，纯五度，纯四度，大六度，大三度，小三度，小六度，小七度，三全音，大二度，大七度，小二度</p><p>通过在钢琴上弹奏对比可知，越向左边的和声越<em>协和</em>，但也越<em>空洞</em>，就是好像只有一个音，不够<em>饱满</em>；越向右边的和声越<em>难听</em>，但也越<em>饱满</em>。人们根据这一特征，将和声的协和程度分为<strong>极完全协和、完全协和、不完全协和、不协和与极不协和</strong>这五类，如下图所示：</p><p><img src="/images/25230031-c61ee624ca7b46569db31f52437438c5.png" alt="各音程的协和程度"></p><p>我们做一个实验来验证。</p><ul><li>比如$C4$和$G4$之间是完全协和的纯五度，他们的弦长比是$3:2$，最小公倍数是$6$，那么他们的拍音频率就是弦长为$C4$弦长$2$倍的弦所发出的声音的频率，显然就是$C3$的音。</li><li>可以在钢琴上面按$C4,G4,C3$，可以感觉到$C4$和$G4$把$C3$增强了。同理，$A6$和$B6$这两个小二度音程的弦长比是$16:15$，最小公倍数$240$，拍音频率对应的音为$B2$，然而$B2$与$A6$和$B6$<em>相隔太远</em>了，我们无法听出拍音增强的效果。</li></ul><p>PS: 和声理论已经发展为一门学科，称为和声学，内容是相当复杂的，这里只做简单介绍，感兴趣的可以阅读《和声学》，下面给出一份参考pdf：<a href="/images/音乐自学丛书·和声学基础教程.pdf">音乐自学丛书·和声学基础教程</a></p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 音乐 </tag>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础乐理与数学（一）</title>
      <link href="/2018/08/31/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/08/31/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="基础乐理与数学（一）"><a href="#基础乐理与数学（一）" class="headerlink" title="基础乐理与数学（一）"></a>基础乐理与数学（一）</h1><h2 id="声学基础"><a href="#声学基础" class="headerlink" title="声学基础"></a>声学基础</h2><p>　　乐理的基本内容包括：和声、调式、节奏、结构、曲式。主要来说，音乐的组成从简单到复杂依次是：纯音、谐波、拍音、和声、调式、曲式。下面只介绍前几种基本的音乐组成单元。</p><h3 id="音与音的复合"><a href="#音与音的复合" class="headerlink" title="音与音的复合"></a>音与音的复合</h3><ul><li>音：</li></ul><p>能被人类的听觉所感知的一段声波，通常可以用一个声波的波形来表示。</p><p>音的本质是一段声波（根据人耳辨别范围可知声波频率应在$20{\rm Hz} -20000\rm Hz$之内）。</p><p>一般音乐中的每个音都是周期性的，这在后面音的谐和部分会提到。</p><p>音是可以叠加的，后一个音出现时，前一个音可能尚未消失，这就关联到声波方面的<strong>傅立叶变换</strong>。<strong>音是音乐的最基本的组成单位。</strong></p><ul><li>音的复合：</li></ul><p>说到声波最先想到的最简单的波形即是正弦波，即以某个固定频率进行简谐振动所产生的声波。</p><p>这种声波被称为<strong>纯音</strong>，比如音叉的声音或$220\rm Hz$正弦波。</p><p>纯音显然几乎没有音色可言，音与音的复合形成了<strong>复合音</strong>。</p><p>复合音一般分为两种：谐波叠加与拍音叠加。</p><a id="more"></a><h3 id="谐波叠加与拍音叠加"><a href="#谐波叠加与拍音叠加" class="headerlink" title="谐波叠加与拍音叠加"></a>谐波叠加与拍音叠加</h3><p>将一个标准的正弦波作为基准，称作<strong>基波</strong>。<strong>谐波</strong>就是比基波的频率高整数倍的波，钢琴按下一个键或小提琴拉响一根弦都会在基波的基础上产生多个谐波，音乐人往往将谐波称为<strong>泛音</strong>。例如某个纯音声波的频率是$f$，将此纯音作为基波，其谐波的频率可为$2f$、$3f$、$4f$、……，这些谐波分别称为二次谐波、三次谐波、四次谐波等。如下图所示。</p><p><img src="/images/24113955-73d792eaa9f44d35ae208c8e6db35571.png" alt="基波与谐波的关系"></p><p>最上面的是基波，从第二行往下分别是一次谐波、二次谐波等等。若一个复合音由基波与及其谐波相叠加构成，则称该复合音为谐波叠加，它的频率为基波频率。基波与谐波叠加构成复合音的过程见图3所示。</p><p><img src="/images/ppp.gif" alt="基波与谐波复合构成复合音"></p><p>实际上，所有传统乐器所发出的音都是复合音，由振幅最大的基波和一些列振幅较小的谐波叠加构成。那么我们就可以给出单音的定义了：<strong>单音</strong>特指单一乐器演奏独立的一个音发出的声波（谐波叠加），其基波的频率称为<strong>音高</strong>。不同乐器的单音所叠加的谐波在频率和振幅上都不相同，因此乐器的音色千差万别。小提琴的单音就是典型的一种谐波叠加，声音对应的波型为：</p><p><img src="/images/vlin.jpg" alt=""></p><ul><li>谐波叠加</li></ul><p>我们将一个标准的正弦波作为基准，称为<strong>基波</strong>，<strong>谐波</strong>就是比基波的频率高整数倍的波。钢琴、小提琴等弦乐器产生的一个音一般都是多个谐波的叠加，在音乐领域被称为<strong>泛音</strong>。一般将一个音中振幅最大的波作为基波，其余波的频率都是这个波的倍数。</p><p>也就是说，<em>组成一个谐波叠加的音的所有正弦波$k\sin(x \omega)$的频率都是基波的倍数。</em></p><ul><li>拍音叠加</li></ul><p>一个拍音是由来自同一种乐器或不同乐器的两个单音相互叠加，形成具有规律性强弱变化的振动。与谐波不同的是，拍音一般要求这两个音的振幅相近，但不要求频率为倍数关系。粗略理解就是：<em>如果组成复合音的纯音频率互为倍数则为谐波叠加，否则为拍音叠加。</em></p><ul><li>复合音的频率与“谐和”</li></ul><p>只考虑最简单的情况，两个音的频率分别为$a$和$b$，则这两个音的叠加的频率应为多少？</p><blockquote><p>复合音的周期是这两个音的周期的最小公倍数，即$\gcd\left ( \dfrac{1}{a},\dfrac{1}{b} \right )$，频率即为周期的倒数。</p></blockquote><p>但是，如果两个音的频率均为无理数，例如$\sqrt{3}$与$\sqrt{5}$，理论上这不是一个周期函数，这时需要用到近似。这个复合音的频率可以认为是$\dfrac{1}{4\sqrt{3}}$，因为$\dfrac{ \sqrt{3} }{ \sqrt{5} } \approx 0.7746$，接近于$0.75$，也就是$3:4$。因此这个拍音的“听感频率”大约在$\dfrac{\sqrt{5}}{4}$到$\dfrac{\sqrt{3}}{3}$之间。</p><p>人耳一般会认为复合音的频率越高，声音越悦耳，<strong>即两个音的频率的倒数的最小公倍数应尽量小</strong>，这样的两个音被称为<em>彼此谐和</em>的。</p><p>这里出现了一个数学方面的拓展：复合音的频率与<strong>测度论</strong>的关系。</p><h2 id="乐律与调式"><a href="#乐律与调式" class="headerlink" title="乐律与调式"></a>乐律与调式</h2><h3 id="十二平均律"><a href="#十二平均律" class="headerlink" title="十二平均律"></a>十二平均律</h3><ul><li>平均律</li></ul><p>首先我们要知道，跨越一个八度音程的两个音的频率相差一倍，即$a:b=1:2$。</p><p>现在我们将一个八度音程等分成十二个部分，那么显然第一个音是$a$，第二个音是$\displaystyle a\cdot 2^\frac{1}{12}$，第三个是$\displaystyle a\cdot 2^\frac{2}{12}$，…，第十三个是$2a$。</p><p>十二平均律中，任意两个相邻的音的频率比为$2^\frac{1}{12}$任两个相邻的音之间的音数为$0.5$。</p><ul><li>音程名称与音数</li></ul><p>学过乐理的人一定能辨别每两个音相差的音程名称，而每个音程名称都对应了一个固定的音数，如下表：</p><div class="table-container"><table><thead><tr><th>相差音数</th><th>0.5</th><th>1</th><th>1.5</th><th>2</th><th>2.5</th><th>3</th><th>3.5</th><th>4</th><th>4.5</th><th>5</th><th>5.5</th><th>6</th></tr></thead><tbody><tr><td>音程名称</td><td><strong>小二度</strong></td><td><strong>大二度</strong></td><td><strong>小三度</strong></td><td><strong>大三度</strong></td><td><strong>纯四度</strong></td><td><strong>三全音</strong></td><td><strong>纯五度</strong></td><td><strong>小六度</strong></td><td><strong>大六度</strong></td><td><strong>小七度</strong></td><td><strong>大七度</strong></td><td><strong>纯八度</strong></td></tr></tbody></table></div><ul><li>五线谱</li></ul><p>需要注意的是，第一个音程的$A$音的频率是$440\rm Hz$，这样我们就可以轻松地计算出任何一个音的频率了。</p><h3 id="五度相生律"><a href="#五度相生律" class="headerlink" title="五度相生律"></a>五度相生律</h3><p>前面提到，人们一般会认为两个彼此谐和的音之间会较为悦耳，但我们遗憾地发现，用十二平均律规定的各个音大部分都是完全不谐和的，这使人们希望找到一个彼此更加谐和的划分方法。</p><p>我们将一个弦分成$1:2$两部分，则这两部分的频率比为$3:2$，如果在前$\dfrac{1}{3}$中再分出前，则$\dfrac{1}{3}$两部分的频率比变为$\dfrac{9}{4}$，以此类推，我们将这个频率列成表：</p><div class="table-container"><table><thead><tr><th>$n$</th><th>频率</th><th>倍率</th></tr></thead><tbody><tr><td>$1$</td><td>$\dfrac{3f}{2}$</td><td>$1.5$</td></tr><tr><td>$2$</td><td>$\dfrac{9f}{4}$</td><td>$2.25$</td></tr><tr><td>$3$</td><td>$\dfrac{27f}{8}$</td><td>$3.375$</td></tr><tr><td>$4$</td><td>$\dfrac{81f}{16}$</td><td>$5.0625$</td></tr><tr><td>$5$</td><td>$\dfrac{243}{32}$</td><td>$7.59375$</td></tr></tbody></table></div><p>这个倍率已经超过$2$了，那么我们将每个值除以不大于它的最接近的$2$的次幂，从小到大排列：$\{1.125, 1.265625 ,1.333, 1.5, 1.6875, 1.8984375\}$。$f$自身的倍率为$1$，$2f$为$2$，把这$8$个倍率一起画在二维坐标系中，如图所示。</p><p><img src="/images/27162624-979ee68f2a5a4cbba0cb55b8b81e27c8.png" alt=""></p><p>这个和呈完美指数增长的划分相差并不多，更奇妙的是，由刚才的推导，这些音两两谐和。</p><h3 id="纯律"><a href="#纯律" class="headerlink" title="纯律"></a>纯律</h3><p>我们在五度相生律中取得了良好的效果，继续这个思路，接着将表列出来：</p><div class="table-container"><table><thead><tr><th>n</th><th>频率</th><th>倍率</th></tr></thead><tbody><tr><td>$1$</td><td>$\dfrac{3}{2}$</td><td>$1.5$</td></tr><tr><td>$2$</td><td>$\dfrac{9}{4}$</td><td>$2.25$</td></tr><tr><td>$3$</td><td>$\dfrac{27}{8}$</td><td>$3.375$</td></tr><tr><td>$4$</td><td>$\dfrac{81}{16}$</td><td>$5.0625$</td></tr><tr><td>$5$</td><td>$\dfrac{243}{32}$</td><td>$7.59375$</td></tr><tr><td>$6$</td><td>$\dfrac{729}{64}$</td><td>$11.3906$</td></tr><tr><td>$7$</td><td>$\dfrac{2187}{128}$</td><td>$17.0859$</td></tr><tr><td>$8$</td><td>$\dfrac{6561}{256}$</td><td>$25.6289$</td></tr><tr><td>$9$</td><td>$\dfrac{19683}{512}$</td><td>$38.4434$</td></tr><tr><td>$10$</td><td>$\dfrac{59049}{1024}$</td><td>$57.6650$</td></tr><tr><td>$11$</td><td>$\dfrac{177147}{2048}$</td><td>$86.4976$</td></tr></tbody></table></div><p>由这些倍率产生的12音阶为（用倍率除以它下面的第一个$2^n$而得）：$\{1, 1.0679, 1.125, 1.2014, 1.2656, 1.3515, 1.4238, 1.5, 1.6018, 1.6875, 1.802, 1.8984\}$，把他们画在坐标系中：</p><p><img src="/images/27171215-e40f33d0e8c54bc28beab7e78d57a9e5.png" alt=""></p><p>五度相生律产生$12$音阶（新产生的五个音为绿色）</p><p>这也是一条平滑的折线，且每个音两两谐和，这就是纯律。</p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 音乐 </tag>
            
            <tag> 乐理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Codeforces 985D』Sand Fortress</title>
      <link href="/2018/08/31/%E3%80%8ECodeforces%20985D%E3%80%8FSand%20Fortress/"/>
      <url>/2018/08/31/%E3%80%8ECodeforces%20985D%E3%80%8FSand%20Fortress/</url>
      <content type="html"><![CDATA[<h1 id="『Codeforces-985D』Sand-Fortress"><a href="#『Codeforces-985D』Sand-Fortress" class="headerlink" title="『Codeforces 985D』Sand Fortress"></a>『Codeforces 985D』Sand Fortress</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>窝不想抄题目了…</p><p>题目描述：</p><p>你有$n$堆沙子，最左边的沙子的最大高度不能超过$H$，让你在一个从$1$到$\infty$的一维平面内放沙子，且要满足相邻两个坐标的沙子的高度不能超过$1$。问沙子能够占用的最少坐标点的个数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>因为题目要求相邻两个坐标的沙子高度不能超过$1$，这代表最后一堆沙子的个数也必定为$1$。</p><p>而题目要我们求占用坐标点的最少个数，根据贪心的思想，要使占用的点最少，则我们必须要贪心地令沙子的高度尽可能高。</p><ul><li><p>因为最后一堆的沙子的个数为$1$，所以沙子的高度所形成的曲线必定是先增后减的或者一直减小的曲线。</p><ul><li>沙子的高度存在单调性！</li><li>二分答案</li><li><p>不断二分占用坐标的个数即可。</p><p>而二分的$\rm check$函数，我们因为最优的情况下，两两沙堆相差均为$1$，因此我们可以运用等差数列求和公式求出总的沙子堆数，并用它与$n$进行对比进行二分即可。</p><p>值得一提的是，当枚举出$n$为奇数的时候，会出现有两个坐标的值均相当的情况，需要注意</p></li></ul></li></ul><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, h;</span><br><span class="line"><span class="keyword">const</span> ll cnt = <span class="number">2000000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> ll &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= h)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= cnt) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> (x * (x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> ll a = ((x - h) &gt;&gt; <span class="number">1</span>) + h;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= cnt) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> ((x - h) &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ((a * (a + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + ((a + h) * (a + <span class="number">1</span> - h) &gt;&gt; <span class="number">1</span>)) &gt;= n;</span><br><span class="line"><span class="keyword">return</span> ((a * (a + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + ((a - <span class="number">1</span> + h) * (a - h) &gt;&gt; <span class="number">1</span>)) &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h;</span><br><span class="line"><span class="keyword">register</span> ll ln = <span class="number">1</span>, rn = n;</span><br><span class="line"><span class="keyword">while</span> (ln &lt;= rn)</span><br><span class="line">&#123;</span><br><span class="line">ll mid = (ln + rn) &gt;&gt; <span class="number">1l</span>l;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) rn = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ln = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rn + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『Codeforces 932E』Team Work</title>
      <link href="/2018/08/30/%E3%80%8ECodeforces%20932E%E3%80%8FTeam%20Work/"/>
      <url>/2018/08/30/%E3%80%8ECodeforces%20932E%E3%80%8FTeam%20Work/</url>
      <content type="html"><![CDATA[<h1 id="『Codeforces-932E』Team-Work"><a href="#『Codeforces-932E』Team-Work" class="headerlink" title="『Codeforces 932E』Team Work"></a>『Codeforces 932E』Team Work</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>time limit per test</p><p>2 seconds</p><p>memory limit per test</p><p>256 megabytes</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You have a team of $N$ people. For a particular task, you can pick any non-empty subset of people. The cost of having $x$ people for the task is $x^k$.</p><p>Output the sum of costs over all non-empty subsets of people.</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Only line of input contains two integers $N (1 ≤ N ≤ 10^9)$ representing total number of people and $k (1 ≤ k ≤ 5000)$.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output the sum of costs for all non empty subsets modulo 109 + 7.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><textarea name="text" id="text" cols="10" rows="1" style="background: transparent; border-style: none; overflow:hidden;">1 1</textarea><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><textarea name="text" id="text" cols="10" rows="1" style="background: transparent; border-style: none; overflow:hidden;">1</textarea><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><textarea name="text" id="text" cols="10" rows="1" style="background: transparent; border-style: none; overflow:hidden;">3 2</textarea><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><textarea name="text" id="text" cols="10" rows="1" style="background: transparent; border-style: none; overflow:hidden;">24</textarea><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example, there is only one non-empty subset $\{1\}$ with cost  $1^1 = 1$</p><p>In the second example, there are seven non-empty subsets.</p><ul><li><p>$\{1\}$ with cost $1^2 = 1$</p></li><li><p>$\{2\}$ with cost  $1^2 = 1$</p></li><li><p>$\{1, 2\}$ with cost $2^2 = 4$</p></li><li><p>$\{3\}$ with cost $1^2 = 1$</p></li><li><p>$\{1, 3\}$ with cost $2^2 = 4$</p></li><li><p>$\{2, 3\}$ with cost $2^2 = 4$</p></li><li><p>$\{1, 2, 3\}$ with cost $3^2 = 9$</p></li></ul><p>The total cost is $1 + 1 + 4 + 1 + 4 + 4 + 9 = 24$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这题还是挺难的…稍不注意就会掉到什么二项式反演的坑里面去…<del>（其实还是做题少</del></p><p>正解是什么呢？</p><p>设函数$\displaystyle f(x)=(1+x)^n=\sum_{r=0}^nC_n^rx^r$</p><p>两边形式地求导：$\displaystyle f’(x)=n(1+x)^{n-1}=\sum_{r=1}^nC_n^rrx^{r-1}$</p><p>再两边乘$x$：$\displaystyle xf’(x)=nx(1+x)^{n-1}=\sum_{r=1}^nC_n^rrx^{r}$</p><p>然后你发现了什么？<br>请思考 for some time</p><p>对于$f(x)$，题目所给的公式就是我们对它进行上面的操作（求导后乘$x$）$k$次后$x=1$的值！</p><p>那么这道题现在就转化成关于$f(x)$的问题了</p><p>设$f_{a,b,c}$是对$x^b(1+x)^c$做$a$次操作后$x=1$的值</p><p>那么最终的答案即为$f_{k,0,n}$</p><p>转移：$f_{a,b,c}=b∗f_{a-1,b,c}+c∗f_{a-1,b+1,c-1}$</p><p>$a=0$时,$f_{a,b,c}=2^c$</p><p>复杂度实际上是$O(k^2)$，因为$b+c≡n$</p><p>这题目的<code>long long</code>一定不能忘了开！！！（栽坑</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line">ll f[MAXN][MAXN];</span><br><span class="line">ll n, k;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fast_pow</span><span class="params">(ll x, ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; a; a &gt;&gt;= <span class="number">1</span>, x = <span class="number">1l</span>l * x * x % mod) <span class="keyword">if</span> (a &amp; <span class="number">1</span>) ans = <span class="number">1l</span>l * ans * x % mod;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dp</span><span class="params">(<span class="keyword">const</span> ll &amp;a, <span class="keyword">const</span> ll &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (f[a][b] &gt;= <span class="number">0</span>) <span class="keyword">return</span> f[a][b];</span><br><span class="line"><span class="keyword">register</span> ll c = n - b;</span><br><span class="line"><span class="keyword">if</span> (!a) &#123; f[a][b] = fast_pow(<span class="number">2</span>, c); <span class="keyword">return</span> f[a][b]; &#125;</span><br><span class="line">f[a][b] = (<span class="number">1l</span>l * b * dp(a - <span class="number">1</span>, b) + <span class="number">1l</span>l * c * dp(a - <span class="number">1</span>, b + <span class="number">1</span>)) % mod;</span><br><span class="line"><span class="keyword">return</span> f[a][b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(ll &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_read(n), _read(k);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, dp(k, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> Tricks </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 012B』Splatter Painting</title>
      <link href="/2018/08/30/%E3%80%8EAGC%20012B%E3%80%8FSplatter%20Painting/"/>
      <url>/2018/08/30/%E3%80%8EAGC%20012B%E3%80%8FSplatter%20Painting/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-012B』Splatter-Painting"><a href="#『AGC-012B』Splatter-Painting" class="headerlink" title="『AGC 012B』Splatter Painting"></a>『AGC 012B』Splatter Painting</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Time limit : 2sec / Memory limit : 256MB</p><p><a href="https://agc012.contest.atcoder.jp/tasks/agc012_b" target="_blank" rel="noopener">door♂</a></p><p>题意简述：可以参考图，问你最后的染色情况</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>因为后面的染色会覆盖前面的，我们就倒过来处理，另外保存每个点的范围</p><p>比如$1-2-3-4-5-6$，</p><p>我们从$3$处理，距离是$2$<br>$3$的处理范围$2$<br>$2$的处理范围$1$<br>$1$的处理范围$0$<br>$4$的处理范围$1$<br>$5$的处理范围$0$</p><p>于是$1,5$已经到染色边界了</p><p>那么每次染色我们都比较上一次这个点的处理范围，比这一次的大，说明一定会被上一次的覆盖，没必要遍历下去了，或者处理没有染色的部分</p><p>Code:</p><div><div class="fold_hider"><div class="close hider_title">Click to show/hide the code</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q[MAXN];</span><br><span class="line"><span class="keyword">int</span> color[MAXN];</span><br><span class="line"><span class="keyword">int</span> flag[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> v[MAXN], d[MAXN], c[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cnt, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!color[x])</span><br><span class="line">color[x] = c;</span><br><span class="line"><span class="keyword">if</span> (flag[x] &gt;= cnt)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">flag[x] = cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q[x].size(); i++)</span><br><span class="line">dfs(q[x][i], cnt - <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">q[x].push_back(y);</span><br><span class="line">q[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; d[i] &gt;&gt; c[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">dfs(v[i], d[i], c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; color[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 012A』AtCoder Group Contest</title>
      <link href="/2018/08/30/%E3%80%8EAGC%20012A%E3%80%8FAtCoder%20Group%20Contest/"/>
      <url>/2018/08/30/%E3%80%8EAGC%20012A%E3%80%8FAtCoder%20Group%20Contest/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-012A』AtCoder-Group-Contest"><a href="#『AGC-012A』AtCoder-Group-Contest" class="headerlink" title="『AGC 012A』AtCoder Group Contest"></a>『AGC 012A』AtCoder Group Contest</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Time limit : 2sec / Memory limit : 256MB</p><p>题意：给$3N$个数，$3​$个一组，我们取每个组第二大的数出来相加，问最大能够是多少</p><p>还是…还是弄个door吧。。</p><p><a href="https://agc012.contest.atcoder.jp/tasks/agc012_a" target="_blank" rel="noopener">door♂</a></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>排序，取$2,4,6,8\dots$就行</p><p>Code:</p><div><div class="fold_hider"><div class="close hider_title">Click to show/hide the code</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">3</span> * <span class="number">123456</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmd</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(ll &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> * n; i++) _read(a[i]);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">sort(a + <span class="number">1</span>, a + <span class="number">1</span> + <span class="number">3</span> * n, cmd);</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">sum += a[i];</span><br><span class="line">i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 003A』Wanna go back home</title>
      <link href="/2018/08/30/%E3%80%8EAGC%20003A%E3%80%8FWanna%20go%20back%20home/"/>
      <url>/2018/08/30/%E3%80%8EAGC%20003A%E3%80%8FWanna%20go%20back%20home/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-003A』Wanna-go-back-home"><a href="#『AGC-003A』Wanna-go-back-home" class="headerlink" title="『AGC 003A』Wanna go back home"></a>『AGC 003A』Wanna go back home</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>传送门：</p><p><a href="https://agc003.contest.atcoder.jp/tasks/agc003_a" target="_blank" rel="noopener">传送door♂</a></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然，我们可以得到以下结论：</p><ul><li>如果$S$和$N$一个出现而另一个没有出现，显然是不行的</li><li>如果$E$和$W$一个出现而另一个没有出现，显然是不行的</li><li>除了以上的两种情况，其他情况都可行</li></ul><p>代码就很easy了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> S, E, N, W;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'S'</span>) S = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'E'</span>) E = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'N'</span>) N = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'W'</span>) W = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((S ^ N) || (E ^ W)) <span class="built_in">puts</span> (<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span> (<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 003B』Simplified mahjong</title>
      <link href="/2018/08/30/%E3%80%8EAGC%20003B%E3%80%8FSimplified%20mahjong/"/>
      <url>/2018/08/30/%E3%80%8EAGC%20003B%E3%80%8FSimplified%20mahjong/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-003B』Simplified-mahjong"><a href="#『AGC-003B』Simplified-mahjong" class="headerlink" title="『AGC 003B』Simplified mahjong"></a>『AGC 003B』Simplified mahjong</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>算了懒得搞，直接放传送门了：</p><p><a href="https://agc003.contest.atcoder.jp/tasks/agc003_b" target="_blank" rel="noopener">传送door♂</a></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>如果没有$A_i$的值是0，那么答案始终是$\left \lfloor \dfrac{S}{2} \right \rfloor$，其中$S$是卡牌的总数</li><li>如果有$A_i$的值是0，那么你不能使用有$i$的卡片，所以你可以把这个序列从$i$的地方断开，然后对于没一块单独处理</li><li>一共至多处理$n$次，所以时间复杂度是$O(n)$的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll sz[<span class="number">100001</span>];</span><br><span class="line">ll a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(ll &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _read(n);</span><br><span class="line">    <span class="keyword">register</span> ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) _read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> ll qwe = min (a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((a[i] - qwe) &amp; <span class="number">1</span> &amp;&amp; qwe) qwe--;</span><br><span class="line">    ans += qwe;</span><br><span class="line">    a[i] -= qwe;</span><br><span class="line">    a[i + <span class="number">1</span>] -= qwe;</span><br><span class="line">    ans += a[i] / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 003C』BBuBBBlesort!</title>
      <link href="/2018/08/30/%E3%80%8EAGC%20003C%E3%80%8FBBuBBBlesort!/"/>
      <url>/2018/08/30/%E3%80%8EAGC%20003C%E3%80%8FBBuBBBlesort!/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-003C』BBuBBBlesort"><a href="#『AGC-003C』BBuBBBlesort" class="headerlink" title="『AGC 003C』BBuBBBlesort!"></a>『AGC 003C』BBuBBBlesort!</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>算了懒得搞，直接放传送门了：</p><p><a href="https://agc003.contest.atcoder.jp/tasks/agc003_c" target="_blank" rel="noopener">传送door♂</a></p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题其实挺简单的</p><p>注意我们可以不花费任何代价交换隔一个的两个字符</p><p>那么可以注意到我们的代价只跟奇偶性有关了</p><p>可以发现，如果有$k$个奇数在偶数位上，那么必有$k$个偶数在奇数位上</p><p>那么我们花的总代价就是$k$（把奇数为放到奇数位上的代价）</p><p>离散化之后直接扫一遍统计答案即可</p><div><div class="fold_hider"><div class="close hider_title">Click to show/hide the code</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; in[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">_read(in[i].first);</span><br><span class="line">in[i].second = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(in, in + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i].second &amp; <span class="number">1</span> != i &amp; <span class="number">1</span>)</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『AGC 002C』Knot Puzzle</title>
      <link href="/2018/08/30/%E3%80%8EAGC%20002C%E3%80%8FKnot%20Puzzle/"/>
      <url>/2018/08/30/%E3%80%8EAGC%20002C%E3%80%8FKnot%20Puzzle/</url>
      <content type="html"><![CDATA[<h1 id="『AGC-002C』Knot-Puzzle"><a href="#『AGC-002C』Knot-Puzzle" class="headerlink" title="『AGC 002C』Knot Puzzle"></a>『AGC 002C』Knot Puzzle</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Time limit : 2sec / Memory limit : 256MB</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>We have $N$ pieces of ropes, numbered 1 through  $N$. The length of piece $i$ is $a_i$.</p><p>At first, for each $i(1≤i≤N−1)$, piece $i$ and piece $i+1$ are tied at the ends, forming one long rope with  $N-1$ knots. Snuke will try to untie all of the knots by performing the following operation repeatedly:</p><ul><li>Choose a (connected) rope with a total length of at least $L$, then untie one of its knots.</li></ul><p>Is it possible to untie all of the $N−1$ knots by properly applying this operation? If the answer is positive, find one possible order to untie the knots.</p><a id="more"></a><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li>$2≤N≤10^5$</li><li>$1≤L≤10^9$</li><li>$1≤a_i≤10^9$</li><li>All input values are integers.</li></ul><hr><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input is given from Standard Input in the following format:</p><p>$N\ L$<br>$a_1\ a_2\ \dots\ a_n$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>If it is not possible to untie all of the $N−1$ knots, print <code>Impossible</code>.</p><p>If it is possible to untie all of the knots, print <code>Possible</code>, then print another $N−1​$ lines that describe a possible order to untie the knots. The $j​$-th of those $N−1​$ lines should contain the index of the knot that is untied in the $j​$-th operation. Here, the index of the knot connecting piece $i​$ and piece $i+1​$ is  $i​$.</p><p>If there is more than one solution, output any.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><textarea name="text" id="text" cols="20" rows="2" style="background: transparent; border-style: none; overflow:hidden;">3 5030 20 10</textarea><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><textarea name="text" id="text" cols="20" rows="3" style="background: transparent; border-style: none; overflow:hidden;">Possible21</textarea><p>If the knot 1 is untied first, the knot 2 will become impossible to untie.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><textarea name="text" id="text" cols="10" rows="2" style="background: transparent; border-style: none; overflow:hidden;">2 2110 10</textarea><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><textarea name="text" id="text" cols="20" rows="1" style="background: transparent; border-style: none; overflow:hidden;">Impossible</textarea><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><textarea name="text" id="text" cols="20" rows="3" style="background: transparent; border-style: none; overflow:hidden;">Possible5 5010 20 30 40 50</textarea><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><textarea name="text" id="text" cols="10" rows="5" style="background: transparent; border-style: none; overflow:hidden;">Possible1234</textarea><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这题的充分必要条件就是有两段绳子的长度$\geq L$</p><p>必要性证明：不断删绳子总归会删到只有一个结的情况，如果没有两段相邻的绳子的长度$\geq L$那么肯定删不下去</p><p>充分性证明：一旦出现了满足题意的两段相邻的绳子，我们可以从左边和右边分别从头删，这样肯定长度不会小于$L$</p><p>Code:</p><div><div class="fold_hider"><div class="close hider_title">Click to show/hide the code</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, L, lstlength = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **Argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_read(N), _read(L);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_read(x);</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">lstlength = x;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x + lstlength &gt;= L)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Possible"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; ++j)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, j + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = N - <span class="number">2</span>; j &gt; i - <span class="number">1</span>; --j)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, j + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">lstlength = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tricks </tag>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『JZOJ 4721』【NOIP2016提高A组模拟8.21】最长公共子序列</title>
      <link href="/2018/08/29/%E3%80%8EJZOJ-4721%E3%80%8F%E3%80%90NOIP2016%E6%8F%90%E9%AB%98A%E7%BB%84%E6%A8%A1%E6%8B%9F8.21%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/08/29/%E3%80%8EJZOJ-4721%E3%80%8F%E3%80%90NOIP2016%E6%8F%90%E9%AB%98A%E7%BB%84%E6%A8%A1%E6%8B%9F8.21%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="4721-【NOIP2016提高A组模拟8-21】最长公共子序列"><a href="#4721-【NOIP2016提高A组模拟8-21】最长公共子序列" class="headerlink" title="4721. 【NOIP2016提高A组模拟8.21】最长公共子序列"></a>4721. 【NOIP2016提高A组模拟8.21】最长公共子序列</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>DJL为了避免成为一只咸鱼，来找Johann学习怎么求最长公共子序列。<br>经过长时间的摸索和练习，DJL终于学会了怎么求LCS。Johann感觉DJL孺子可教，就给他布置了一个课后作业：<br>给定两个长度分别为$n$和$m$的序列，序列中的每个元素都是正整数。保证每个序列中的各个元素互不相同。求这两个序列的最长公共子序列的长度。<br>DJL最讨厌重复劳动，所以不想做那些做过的题。于是他找你来帮他做作业。</p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数$n$和$m$，表示两个数列的长度。<br>第二行一行$n$个整数$a_1,a_2,…,a_n$，保证$1 \leq a_i \leq 10^9$ 。<br>第三行一行$m$个整数$b_1,b_2,…,b_m$，保证$1 \leq b_i \leq 10^9$ 。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数，表示两个数列的最长公共子序列的长度。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><textarea rows="3" cols="20" style="background: transparent; border-style: none; overflow:hidden;">6 61 3 5 7 9 83 4 5 6 7 8</textarea><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><textarea rows="1" cols="20" style="background: transparent; border-style: none; overflow:hidden;">4</textarea><h3 id="Data-Constraint"><a href="#Data-Constraint" class="headerlink" title="Data Constraint"></a>Data Constraint</h3><p>对于$40\%$的数据，$n, m≤3000$<br>对于$100\%$的数据，$n, m≤300000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这题连zyx都做出来了…我太弱了。。</p><p>（（<del>其实是因为没有看清题目里面告诉了我元素互不相同。。。。。</del></p><p>好吧，我们只要构建一个映射</p><p>将映射$A_i \rightarrow i$用在$B$上，对$B$求$\rm LIS$即可，若$A$中没有$B_i$就直接跳过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300000 + 10 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], n, m;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _read(<span class="keyword">int</span> &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(t)) t = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(t))</span><br><span class="line">&#123;</span><br><span class="line">x = x * <span class="number">10</span> + t - <span class="string">'0'</span>;</span><br><span class="line">t = getchar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **Argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_read(n), _read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_read(x);</span><br><span class="line">s[x] = i;</span><br><span class="line">&#125;</span><br><span class="line">fill(f, f + n + <span class="number">1</span>, <span class="number">2147483647</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_read(x);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> t = s[x];</span><br><span class="line"><span class="keyword">if</span> (t) *lower_bound(f, f + m, t) = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lower_bound(f, f + m, <span class="number">2147483647</span>) - f);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较短，就是比较慢。。。。</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> Tricks </tag>
            
            <tag> sort </tag>
            
            <tag> JZOJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记录一次非常感人的Mathematica Animation(Lissajous曲线)...</title>
      <link href="/2018/08/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%9D%9E%E5%B8%B8%E6%84%9F%E4%BA%BA%E7%9A%84Mathematica%20Animation/"/>
      <url>/2018/08/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%9D%9E%E5%B8%B8%E6%84%9F%E4%BA%BA%E7%9A%84Mathematica%20Animation/</url>
      <content type="html"><![CDATA[<h1 id="记录一次非常感人的Mathematica-Animation…"><a href="#记录一次非常感人的Mathematica-Animation…" class="headerlink" title="记录一次非常感人的Mathematica Animation…"></a>记录一次非常感人的Mathematica Animation…</h1><p>自己突发奇想想做一次Lissajous曲线。。</p><p>Mathematica代码咯：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animate</span>[<span class="keyword">ParametricPlot</span>[&#123;Sin[13 u], Sin[18 u]&#125;, &#123;u, 0, a&#125;, </span><br><span class="line">  <span class="keyword">PlotLabel</span> -&gt; <span class="string">"u="</span> + a, <span class="keyword">PlotPoints</span> -&gt; <span class="number">200</span>, </span><br><span class="line">  <span class="keyword">PlotRange</span> -&gt; &#123;&#123;-1, 1&#125;, &#123;-1, 1&#125;&#125;],</span><br><span class="line"> &#123;a, (10)^(-100), 2 Pi&#125;, <span class="keyword">AnimationRunning</span> -&gt; <span class="keyword">True</span>, </span><br><span class="line"> <span class="keyword">AnimationRate</span> -&gt; <span class="number">0.05</span>, <span class="keyword">RefreshRate</span> -&gt; <span class="number">120</span>, <span class="keyword">AnimationRepetitions</span> -&gt; <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>但是我们应该如何导出视频呢？</p><a id="more"></a><p>。。。这真是令人想砸电脑</p><p>你看我的速率和帧率是不是调得很完美，，结果你就这么开心地导出了：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Export</span>[</span><br><span class="line"> <span class="string">"D:\\Lissajous曲线.avi"</span>, %]</span><br></pre></td></tr></table></figure><p>然后：卧槽这个简直有毒吧跑这么快干什么？</p><p>于是你就不知道干啥了。。</p><p>我google了一下，然后在一个Forum里面找到了解答：要设置<code>&quot;AnimationDuration&quot;-&gt;秒</code>来确定动画时间…</p><p>还要<code>&quot;FrameRate&quot; -&gt; 秒</code>来确定导出帧率….我tm….</p><p>导致得结果当然是奇慢无比得导出，并且质量还很差，比如说你会这么写：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Export</span>[</span><br><span class="line"> <span class="string">"D:\\Lissajous曲线.avi"</span>, <span class="keyword">Animate</span>[<span class="keyword">ParametricPlot</span>[&#123;Sin[13 u], Sin[18 u]&#125;, &#123;u, 0, a&#125;, </span><br><span class="line">  <span class="keyword">PlotLabel</span> -&gt; <span class="string">"u="</span> + a, <span class="keyword">PlotPoints</span> -&gt; <span class="number">200</span>, </span><br><span class="line">  <span class="keyword">PlotRange</span> -&gt; &#123;&#123;-1, 1&#125;, &#123;-1, 1&#125;&#125;],</span><br><span class="line"> &#123;a, (10)^(-100), 2 Pi&#125;, <span class="keyword">AnimationRunning</span> -&gt; <span class="keyword">True</span>, </span><br><span class="line"> <span class="keyword">AnimationRate</span> -&gt; <span class="number">0.05</span>, <span class="keyword">RefreshRate</span> -&gt; <span class="number">120</span>, <span class="keyword">AnimationRepetitions</span> -&gt; <span class="number">1</span>], <span class="string">"AnimationDuration"</span> -&gt; <span class="number">30</span>, </span><br><span class="line"> <span class="string">"FrameRate"</span> -&gt; <span class="number">30</span>]</span><br></pre></td></tr></table></figure><p>结果你发现这画质跟你在Youtube上面看的240p没什么区别…</p><p>我们为什么不换个思路呢…既然我们都有1080P屏幕…</p><p>直接录屏啊！</p><p>美滋滋…效果如下（x</p><video width="1024" height="552" controls="controls">  <source src="\images\Lissajous.mp4" type="video/mp4">Your browser does not support the video tag.</video><p><del>总结：早日弃掉Export视频保平安</del></p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> MMA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些关于组合的公式......</title>
      <link href="/2018/08/28/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/08/28/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%85%AC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="一些关于组合的公式……"><a href="#一些关于组合的公式……" class="headerlink" title="一些关于组合的公式……"></a>一些关于组合的公式……</h1><p>好吧这个是我想水个<del>资源文…</del></p><p>行吧… 资源都在下面了。。。一共8卷。。（（</p><p><a href="\Vol\Vol.1.PDF">Volume1</a><br><a href="\Vol\Vol.2.PDF">Volume2</a><br><a href="\Vol\Vol.3.PDF">Volume3</a><br><a href="\Vol\Vol.4.PDF">Volume4</a><br><a href="\Vol\Vol.5.PDF">Volume5</a><br><a href="\Vol\Vol.6.PDF">Volume6</a><br><a href="\Vol\Vol.7.PDF">Volume7</a><br><a href="\Vol\Vol.8.PDF">Volume8</a></p>]]></content>
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Schur不等式的学习感想</title>
      <link href="/2018/08/24/Schur%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/"/>
      <url>/2018/08/24/Schur%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/</url>
      <content type="html"><![CDATA[<h1 id="Schur不等式的学习感想"><a href="#Schur不等式的学习感想" class="headerlink" title="Schur不等式的学习感想"></a>Schur不等式的学习感想</h1><h2 id="什么是Schur不等式？"><a href="#什么是Schur不等式？" class="headerlink" title="什么是Schur不等式？"></a>什么是Schur不等式？</h2><p>设$x,y,z\ge 0,r \in \mathbb {R}$，则</p><p>$x^r(x-y)(x-z)+y^r(y-x)(y-z)+z^r(z-y)(z-x)\ge 0$</p><p>当$r=1$时，Schur不等式有几种变形：</p><ul><li>$x^3+y^3+z^3 \geq (x^2y+xy^2+x^2z+xz^2+y^2z+yz^2)-3xyz$</li><li>$(x+y+z)^3 \geq 4(xy+yz+zx)(x+y+z)-9xyz$</li><li>$xyz \geq (x+y-z)(y+z-x)(z+x-y)$</li></ul><p>差不多就是这样（个人感觉变形用的炒鸡多…）</p><p>下面看唯一一道自己做出来的题：（窝太菜了学了这个不等式之后只会做一道）</p><a id="more"></a><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="08年的中国国家集训队测试题"><a href="#08年的中国国家集训队测试题" class="headerlink" title="08年的中国国家集训队测试题"></a>08年的中国国家集训队测试题</h3><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>设$x,y,z&gt;0$，求证：</p><script type="math/tex; mode=display">\displaystyle \frac{xy}{z}+\frac{yz}{x}+\frac{zx}{y}>2\sqrt[3]{x^3 + y^3 + z^3}</script><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>设$a=\dfrac{xy}{z},b=\dfrac{yz}{x},c=\dfrac{zx}{y}$</p><p>那么就有$x=\sqrt{ca},y=\sqrt{ab},z=\sqrt{bc}$</p><p>于是原不等式就可以等价于$(a+b+c)^3&gt;8(ab\sqrt{ab}+bc\sqrt{bc}+ac\sqrt{ac})$</p><p>由Schur不等式，我们知道</p><script type="math/tex; mode=display">\begin{align}(a+b+c)^3 &\geq 4(ab+bc+ca)(a+b+c)-9abc \\& = 4(a^2b+ab^2+b^2c+bc^2+c^2a+ca^2)+3abc \\& \geq 4(2ab\sqrt{ab}+2bc\sqrt{bc}+2ac\sqrt{ac})+3abc\\& > 8(ab\sqrt{ab}+bc\sqrt{bc}+ac\sqrt{ac})\end{align}</script><p>从而得证。</p><p>下一篇会继续讲另外两道Schur不等式的题目，还是挺有趣的，今天就这样吧）</p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数学竞赛 </tag>
            
            <tag> 不等式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>神奇的Mathematica的三角函数</title>
      <link href="/2018/08/21/%E7%A5%9E%E5%A5%87%E7%9A%84Mathematica%E7%9A%84%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/08/21/%E7%A5%9E%E5%A5%87%E7%9A%84Mathematica%E7%9A%84%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="神奇的Mathematica的三角函数"><a href="#神奇的Mathematica的三角函数" class="headerlink" title="神奇的Mathematica的三角函数"></a>神奇的Mathematica的三角函数</h1><p>某天……</p><p>麻麻我要玩三角函数！！</p><p>神奇的事情发生了…</p><p><img src="\images\MMA_1.png" alt=""></p><p>什么鬼？居然不给lz根式…窝生气了，强制让你写根式……</p><p><img src="\images\MMA_2.png" alt=""></p><p>然后这踏马答案就对了？？</p><p>我…………..</p><p>一怒之下，请教了<a href="https://wuyudi.github.io/" target="_blank" rel="noopener">@wuyudi</a>神犇，然后…</p><p><img src="\images\MMA_3.png" alt=""></p><p><img src="\images\shock.jpg" alt=""></p><p><img src="\images\kbt.jpg" alt=""></p><p><img src="\images\cantacc.jpg" alt=""></p><p><img src="\images\xkll.jpg" alt=""></p><p>涨姿势了。。。</p>]]></content>
      
      <categories>
          
          <category> 无聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> MMA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由一道神奇的题目引发的思考</title>
      <link href="/2018/08/19/%E7%94%B1%E4%B8%80%E9%81%93%E7%A5%9E%E5%A5%87%E7%9A%84%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/08/19/%E7%94%B1%E4%B8%80%E9%81%93%E7%A5%9E%E5%A5%87%E7%9A%84%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h1 id="由一道神奇的题目引发的思考"><a href="#由一道神奇的题目引发的思考" class="headerlink" title="由一道神奇的题目引发的思考"></a>由一道神奇的题目引发的思考</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>计算$\displaystyle \sum_\limits{i=1}^\limits{k}i*2^i$</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>观察恒等式：$\displaystyle \sum_\limits{i=0}^\limits{k} r^i=\dfrac{1-r^{k+1}}{1-r} $</p><p>对两边形式地求导，得$\displaystyle\dfrac{\rm d}{ {\rm d} r}\sum_\limits{i=0}^\limits{k} r^i=\sum_\limits{i=0}^\limits{k} i*r^{i-1}=\dfrac{\rm d}{ {\rm d} r}\dfrac{1-r^{k+1}}{1-r}=-(k+1)\dfrac{r^k}{1-r}+\dfrac{1-r^{k+1}}{(1-r)^2}$</p><p>两边同时乘$r$，令$r=2$，得</p><p>$\displaystyle \sum_{i=0}^{k} i \cdot 2^{i}=-2(k+1)2^k/(-1)+2(1-2^{k+1})/(-1)^2=(k+1)2^{k+1}+2-2 \cdot 2^{k+1} $</p><p>化简得$(k-1)2^{k+1}+2$</p><a id="more"></a><h2 id="思考-amp-拓展"><a href="#思考-amp-拓展" class="headerlink" title="思考&amp;拓展"></a>思考&amp;拓展</h2><h3 id="第一次推广"><a href="#第一次推广" class="headerlink" title="第一次推广"></a>第一次推广</h3><p>推广到$\displaystyle \sum_\limits{i=1}^\limits{k}i*m^i$的形式？</p><p>显然，我们只要令上面的$r=m$就可以得到答案为$\displaystyle \dfrac{(k m-k-1) m^{k+1}+m}{(1-m)^2}$</p><h3 id="第二次推广"><a href="#第二次推广" class="headerlink" title="第二次推广"></a>第二次推广</h3><p>推广到$\displaystyle \sum_\limits{i=1}^\limits{k}i^{p}*m^i$的形式？</p><p>考虑<strong>勒奇超越函数</strong>${\displaystyle \Phi(z,s,a)=\sum _{i=0}^{\infty }{\dfrac {z^{i}}{(a+i)^{s}}}} $</p><p>我们发现这个级数的右边好像给我们所求的东西有一些类似，不过…$a$似乎要等于$0$？$s$要等于$-p$？$z$要等于$m$？</p><p>后面的都一样了，前面那个和式的上下界挺讨厌的…</p><p>于是我们引入另外一个东西…叫做<strong>多对数函数</strong>，也是一个特殊函数，解析形式为$\displaystyle \operatorname {Li} _{s}(z)=\sum _{k=1}^{\infty }{z^{k} \over k^{s}} $</p><p>可以发现…当勒奇函数中$a=1$,则化为多重对数函数了（吃瓜群众：你这引导的顺序有问题啊！）</p><p>没办法，我是菜鸡…</p><p>好了，我们不妨换个角度：首先幂次变量都是确定的，不需要改变；那么似乎要变的就是$a$？</p><p>考虑当$a=k+1$的时候（为什么要考虑$k+1$而不是$k$？因为下界是1不是0）</p><p>我们有$\displaystyle \Phi (m,-p,k+1)=\sum _{i=0}^{\infty }{\dfrac {m^{i}}{(k+1+i)^{-p}}}$</p><p>也就是$\displaystyle \Phi (m,-p,k+1)=\sum _{i=0}^{\infty }m^{i}(k+1+i)^{p}$</p><p>貌似没什么卵用？</p><p>但是！我们乘一个$m^{k+1}$的时候，一切都变了！</p><p>我们得到了$\displaystyle m^{k+1}\Phi (m,-p,k+1)=\sum _{i=0}^{\infty }m^{k+1+i}(k+1+i)^{p}$</p><p>哇！这个结果简直太像了…然而该死的上下标还是不给力啊…</p><p>然后，我们用这个神奇的多对数函数去减去我们的结果…这个世道又变了…</p><script type="math/tex; mode=display">\begin{align}\text{Li}_{-p}(m)-m^{k+1}\Phi (m,-p,k+1) & = \sum _{i=1}^{\infty }{m^{i} \over i^{-p}} - \sum _{i=0}^{\infty }m^{k+1+i}(k+1+i)^{p} \\& = \sum _{i=1}^{\infty }{m^{i} i^p} - \sum _{i=0}^{\infty }m^{k+1+i}(k+1+i)^{p} \\& = \sum _{i=1}^{k }{m^{i} i^p}\\\end{align}</script><p>Yes！这就是我们想要的答案。</p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 复分析 </tag>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二项式系数及其反演</title>
      <link href="/2018/08/19/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%8D%E6%BC%94/"/>
      <url>/2018/08/19/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E5%8F%8A%E5%85%B6%E5%8F%8D%E6%BC%94/</url>
      <content type="html"><![CDATA[<h1 id="二项式系数及其反演"><a href="#二项式系数及其反演" class="headerlink" title="二项式系数及其反演"></a>二项式系数及其反演</h1><h2 id="二项式系数-amp-二项式定理"><a href="#二项式系数-amp-二项式定理" class="headerlink" title="二项式系数&amp;二项式定理"></a>二项式系数&amp;二项式定理</h2><p>了解标题之前，我们先要花一些时间复习一下普通的二项式系数：</p><p>$\left( \begin{array}{c}n\\k\end{array} \right) = \dfrac{\Gamma (n + 1)}{\Gamma (k + 1)\Gamma (n - k + 1)}$</p><p>我们对它研究得非常多，例如经典的二项式定理：</p><p>${(x + y)^n} = \left( \begin{array}{c}n\\0\end{array} \right){x^n}{y^0} + \left( \begin{array}{c}n\\1\end{array} \right){x^{n - 1}}{y^1} + \left( \begin{array}{c}n\\2\end{array} \right){x^{n - 2}}{y^2} +  \cdots  + \left( \begin{array}{c}n\\n - 1\end{array} \right){x^1}{y^{n - 1}} + \left( \begin{array}{c}n\\n\end{array} \right){x^0}{y^n}$</p><p>写成和式的形式，也就是</p><p>${(x + y)^n} = \sum\limits_{k = 0}^n {\left( \begin{array}{c}n\\k\end{array} \right)} {x^{n - k}}{y^k} = \sum\limits_{k = 0}^n {\left( \begin{array}{c}n\\k\end{array} \right)} {x^k}{y^{n - k}}$</p><p>证明挺简单的，想必大家都会，这里不会的可以来谈人生了QwQ</p><a id="more"></a><h2 id="广义二项式定理"><a href="#广义二项式定理" class="headerlink" title="广义二项式定理"></a>广义二项式定理</h2><p>这玩意怎么推广？</p><p>${(x + y)^\alpha } = \mathop \sum \limits_{k = 0}^\infty  \left( \begin{array}{c}\alpha \\k\end{array} \right){x^{\alpha  - k}}{y^k}$</p><h3 id="第一种证明"><a href="#第一种证明" class="headerlink" title="第一种证明"></a>第一种证明</h3><p>证明也非常简单</p><p>它可以看成$(1+x)^\alpha$的幂级数展开</p><p>显然函数当$\alpha&gt;0$的时候是analytic的，所以可以通过多次求导得到幂级数中的项： </p><p>$f(x)=\sum_\limits{n\geq 0}\dfrac{f^{(n)}(0)}{n!}x^n$</p><p>令$f(x)=(1+x)^\alpha$，多次求导可得</p><p>${f^{(n)}}(x) = \alpha (\alpha  - 1) \cdots  \cdots (\alpha  - n + 1){(1 + x)^{a - n}}$</p><p>当然这个只对$\alpha&gt;0$有效，对于其它情况，可以用<strong>幂级数倒数</strong>的性质来证明。 </p><p>这个证明可能用的定理太高级，其实还是组合式的比较好，但是可能就比较长就是了…… </p><h3 id="第二种证明"><a href="#第二种证明" class="headerlink" title="第二种证明"></a>第二种证明</h3><p>还是原来的函数$f(x)$，假定它能展开成幂级数$f(x) = \sum\limits_{n \ge 0} {a_n} {x^n}$</p><p>然后我们<del>无比震惊地发现</del>它满足如下的微分方程：</p><p>$(1 + x)f’(x) = \alpha f(x),f(0) = 1$</p><p>这个微分方程又可以写成系数之间的递推式： </p><p>${a_0} = 1,\sum\limits_{n \ge 0} {((n + 1){a_{n + 1}} + n{a_n})x = \sum\limits_{n \ge 0} {\alpha {a_n}{x^n}} } $</p><p>然后就有</p><p>${a_0} = 1,\forall n,n{a_n} = (\alpha  - n - 1){a_{n + 1}}$</p><p>然后解递推方程咯…..</p><p>如果你还是看不懂，可以去<a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86#%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F%E7%9A%84%E8%AF%81%E6%98%8E" target="_blank" rel="noopener">维基百科</a>看详细过程解答。</p><h3 id="组合证明"><a href="#组合证明" class="headerlink" title="组合证明"></a>组合证明</h3><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/7134359?fr=aladdin" target="_blank" rel="noopener">百度百科-二项式定理</a>上面有写，如果你这个都看不懂说明你废了。。</p><h2 id="二项式定理的一些小应用"><a href="#二项式定理的一些小应用" class="headerlink" title="二项式定理的一些小应用"></a>二项式定理的一些小应用</h2><ul><li>当然是帮助证明东西</li></ul><p><strong>证明组合恒等式</strong>：</p><p>比如证明</p><script type="math/tex; mode=display">\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)}^2  = \left( {\begin{array}{*{20}{c}}{2n}\\n\end{array}} \right)</script><p>可以考虑恒等式</p><script type="math/tex; mode=display">{(1 + x)^n}{(1 + x)^n} = {(1 + x)^{2n}}</script><p>然后证明就很显然了</p><p><strong>证明自然数幂求和公式</strong>:</p><p>我没有看懂<del>（留坑）</del>，但是有一篇博客系统地讲述了自然数幂和的各种求法：<a href="https://blog.csdn.net/doyouseeman/article/details/50826293" target="_blank" rel="noopener">解决自然数幂和的方法</a></p><h2 id="二项式反演！"><a href="#二项式反演！" class="headerlink" title="二项式反演！"></a>二项式反演！</h2><h3 id="前置定义-amp-定理"><a href="#前置定义-amp-定理" class="headerlink" title="前置定义&amp;定理"></a>前置定义&amp;定理</h3><p>设$x$为任意复数，$n$是非负整数</p><p>对于广义二项式系数$\left( {\begin{array}{*{20}{c}}x\\n\end{array}} \right)$，有Vandermonde卷积公式：</p><math display="block"> <semantics>  <mrow>   <mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>x</mi><mo>+</mo><mi>y</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>n</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mi>y</mi>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaabmaapaqaauaabeqa  ceaaaeaapeGaamiEaiabgUcaRiaadMhaa8aabaWdbiaad6gaaaaaca  GLOaGaayzkaaGaeyypa0ZaaabCa8aabaWdbmaabmaapaqaauaabeqa  ceaaaeaapeGaamiEaaWdaeaapeGaam4AaaaaaiaawIcacaGLPaaaaS  WdaeaapeGaam4Aaiabg2da9iaaicdaa8aabaWdbiaad6gaa0Gaeyye  IuoakmaabmaapaqaauaabeqaceaaaeaapeGaamyEaaWdaeaapeGaam  OBaiabgkHiTiaadUgaaaaacaGLOaGaayzkaaaaaa@5595@  </annotation> </semantics></math><p>以及展开形式(expand form)</p><math display="block"> <semantics>  <mrow>   <msup>    <mrow>     <mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo></mrow>    <mi>x</mi>   </msup>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>n</mi><mo>=</mo><mn>0</mn></mrow>     <mi>&#x221E;</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>n</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msup>    <mi>t</mi>    <mi>n</mi>   </msup>   <mo>,</mo><msup>    <mrow>     <mo stretchy="false">(</mo><mn>1</mn><mo>&#x2212;</mo><mi>t</mi><mo stretchy="false">)</mo></mrow>    <mrow>     <mo>&#x2212;</mo><mi>x</mi></mrow>   </msup>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>n</mi><mo>=</mo><mn>0</mn></mrow>     <mi>&#x221E;</mi>    </munderover>    <mrow>     <mrow><mo>&#x2329;</mo> <mrow>      <mtable>       <mtr>        <mtd>         <mi>x</mi>        </mtd>       </mtr>       <mtr>        <mtd>         <mi>n</mi>        </mtd>       </mtr>      </mtable></mrow> <mo>&#x232A;</mo></mrow></mrow>   </mstyle><msup>    <mi>t</mi>    <mi>n</mi>   </msup>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbiaacIcacaaIXaGaey4k  aSIaamiDaiaacMcapaWaaWbaaSqabeaapeGaamiEaaaakiabg2da9m  aaqahapaqaa8qadaqadaWdaeaafaqabeGabaaabaWdbiaadIhaa8aa  baWdbiaad6gaaaaacaGLOaGaayzkaaaal8aabaWdbiaad6gacqGH9a  qpcaaIWaaapaqaa8qacqGHEisPa0GaeyyeIuoakiaadshapaWaaWba  aSqabeaapeGaamOBaaaakiaacYcacaGGOaGaaGymaiabgkHiTiaads  hacaGGPaWdamaaCaaaleqabaWdbiabgkHiTiaadIhaaaGccqGH9aqp  daaeWbWdaeaapeWaaaWaa8aabaqbaeqabiqaaaqaa8qacaWG4baapa  qaa8qacaWGUbaaaaGaayzkJiaawQYiaaWcpaqaa8qacaWGUbGaeyyp  a0JaaGimaaWdaeaapeGaeyOhIukaniabggHiLdGccaWG0bWdamaaCa  aaleqabaWdbiaad6gaaaaaaa@6757@  </annotation> </semantics></math><p>其中$\left\langle {\begin{array}{*{20}{c}}x\\n\end{array}} \right\rangle  = \dfrac{x(x + 1) \cdots (x + n - 1)}{n!}$</p><p>且有</p><math display="block"> <semantics>  <mrow>   <mrow><mo>&#x2329;</mo> <mrow>    <mtable>     <mtr>      <mtd>       <mrow>        <mi>x</mi><mo>+</mo><mi>y</mi></mrow>      </mtd>     </mtr>     <mtr>      <mtd>       <mi>n</mi>      </mtd>     </mtr>    </mtable></mrow> <mo>&#x232A;</mo></mrow><mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>&#x2329;</mo> <mrow>      <mtable>       <mtr>        <mtd>         <mi>x</mi>        </mtd>       </mtr>       <mtr>        <mtd>         <mi>k</mi>        </mtd>       </mtr>      </mtable></mrow> <mo>&#x232A;</mo></mrow></mrow>   </mstyle><mrow><mo>&#x2329;</mo> <mrow>    <mtable>     <mtr>      <mtd>       <mi>y</mi>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>      </mtd>     </mtr>    </mtable></mrow> <mo>&#x232A;</mo></mrow></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaamaapaqaauaabeqa  ceaaaeaapeGaamiEaiabgUcaRiaadMhaa8aabaWdbiaad6gaaaaaca  GLPmIaayPkJaGaeyypa0ZaaabCa8aabaWdbmaaamaapaqaauaabeqa  ceaaaeaapeGaamiEaaWdaeaapeGaam4AaaaaaiaawMYicaGLQmcaaS  WdaeaapeGaam4Aaiabg2da9iaaicdaa8aabaWdbiaad6gaa0Gaeyye  IuoakmaaamaapaqaauaabeqaceaaaeaapeGaamyEaaWdaeaapeGaam  OBaiabgkHiTiaadUgaaaaacaGLPmIaayPkJaaaaa@566A@  </annotation> </semantics></math><ul><li><strong>定义1</strong></li></ul><p>$x$为任意数，$n+1$阶矩阵$P_n[x],Q_n[x],D_k(k \in N^*)$分别定义</p><math display="block"> <semantics>  <mrow>   <mtable columnalign="left">    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <msub>        <mrow>         <mo stretchy="false">(</mo><msub>          <mi>P</mi>          <mi>n</mi>         </msub>         <mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow>        <mrow>         <mi>i</mi><mi>j</mi></mrow>       </msub>       <mo>=</mo><mrow><mo>{</mo> <mrow>        <mtable>         <mtr>          <mtd>           <mrow>            <mrow><mo>(</mo>             <mrow>              <mtable>               <mtr>                <mtd>                 <mi>x</mi>                </mtd>               </mtr>               <mtr>                <mtd>                 <mrow>                  <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>                </mtd>               </mtr>              </mtable></mrow>            <mo>)</mo></mrow><mo>,</mo></mrow>          </mtd>          <mtd>           <mrow>            <mi>i</mi><mo>&#x2265;</mo><mi>j</mi></mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mn>0</mn>          </mtd>          <mtd>           <mrow>            <mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow>          </mtd>         </mtr>        </mtable></mrow> </mrow></mrow>     </mtd>    </mtr>    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <msub>        <mrow>         <mo stretchy="false">(</mo><msub>          <mi>Q</mi>          <mi>n</mi>         </msub>         <mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow>        <mrow>         <mi>i</mi><mi>j</mi></mrow>       </msub>       <mo>=</mo><mrow><mo>{</mo> <mrow>        <mtable>         <mtr>          <mtd>           <mrow>            <mrow><mo>&#x2329;</mo> <mrow>             <mtable>              <mtr>               <mtd>                <mi>x</mi>               </mtd>              </mtr>              <mtr>               <mtd>                <mrow>                 <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>               </mtd>              </mtr>             </mtable></mrow> <mo>&#x232A;</mo></mrow><mo>,</mo></mrow>          </mtd>          <mtd>           <mrow>            <mi>i</mi><mo>&#x2265;</mo><mi>j</mi></mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mn>0</mn>          </mtd>          <mtd>           <mrow>            <mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow>          </mtd>         </mtr>        </mtable></mrow> </mrow></mrow>     </mtd>    </mtr>    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <msub>        <mrow>         <mo stretchy="false">(</mo><msub>          <mi>D</mi>          <mi>k</mi>         </msub>         <mo stretchy="false">)</mo></mrow>        <mrow>         <mi>i</mi><mi>j</mi></mrow>       </msub>       <mo>=</mo><mrow><mo>{</mo> <mrow>        <mtable>         <mtr>          <mtd>           <mrow>            <mn>1</mn><mo>,</mo></mrow>          </mtd>          <mtd>           <mrow>            <mi>i</mi><mo>=</mo><mi>j</mi><mo>+</mo><mi>k</mi></mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mrow>            <mn>0</mn><mo>,</mo></mrow>          </mtd>          <mtd>           <mrow>            <mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mrow>          </mtd>         </mtr>        </mtable></mrow> </mrow></mrow>     </mtd>    </mtr>   </mtable></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaafaqaaeWabaaabaaeaaaaaaaaa8qacaGG  OaGaamiua8aadaWgaaWcbaWdbiaad6gaa8aabeaak8qacaGGBbGaam  iEaiaac2facaGGPaWdamaaBaaaleaapeGaamyAaiaadQgaa8aabeaa  k8qacqGH9aqpdaGabaWdaeaafaqabeGacaaabaWdbmaabmaapaqaau  aabeqaceaaaeaapeGaamiEaaWdaeaapeGaamyAaiabgkHiTiaadQga  aaaacaGLOaGaayzkaaGaaiilaaWdaeaapeGaamyAaiabgwMiZkaadQ  gaa8aabaWdbiaaicdaa8aabaWdbiaad+gacaWG0bGaamiAaiaadwga  caWGYbGaam4DaiaadMgacaWGZbGaamyzaaaaaiaawUhaaaWdaeaape  GaaiikaiaadgfapaWaaSbaaSqaa8qacaWGUbaapaqabaGcpeGaai4w  aiaadIhacaGGDbGaaiyka8aadaWgaaWcbaWdbiaadMgacaWGQbaapa  qabaGcpeGaeyypa0Zaaiqaa8aabaqbaeqabiGaaaqaa8qadaaadaWd  aeaafaqabeGabaaabaWdbiaadIhaa8aabaWdbiaadMgacqGHsislca  WGQbaaaaGaayzkJiaawQYiaiaacYcaa8aabaWdbiaadMgacqGHLjYS  caWGQbaapaqaa8qacaaIWaaapaqaa8qacaWGVbGaamiDaiaadIgaca  WGLbGaamOCaiaadEhacaWGPbGaam4CaiaadwgaaaaacaGL7baaa8aa  baWdbiaacIcacaWGebWdamaaBaaaleaapeGaam4AaaWdaeqaaOWdbi  aacMcapaWaaSbaaSqaa8qacaWGPbGaamOAaaWdaeqaaOWdbiabg2da  9maaceaapaqaauaabeqaciaaaeaapeGaaGymaiaacYcaa8aabaWdbi  aadMgacqGH9aqpcaWGQbGaey4kaSIaam4AaaWdaeaapeGaaGimaiaa  cYcaa8aabaWdbiaad+gacaWG0bGaamiAaiaadwgacaWGYbGaam4Dai  aadMgacaWGZbGaamyzaaaaaiaawUhaaaaaaaa@9560@  </annotation> </semantics></math><p>显然，$P_n[0]=Q_n[0]=D_0=I_{n+1}$($I_{n+1}$阶单位矩阵)。设$D_1=D$，那么$D_k=D^k,k \in N^*$。设$(x)_k=\dfrac{\Gamma(x+1)}{\Gamma(k+1)}$，${\langle x \rangle}_k=\dfrac{\Gamma(x+k)}{\Gamma(x)}$，由矩阵乘法和Stirling数的性质，我们得到了一个定理：</p><ul><li><strong>定理1</strong></li></ul><p>$x$为任意数，则有</p><math display="block"> <semantics>  <mrow>   <mtable columnalign="left">    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <msub>        <mi>P</mi>        <mi>n</mi>       </msub>       <mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mstyle displaystyle="true">        <munderover>         <mo>&#x2211;</mo>         <mrow>          <mi>k</mi><mo>=</mo><mn>0</mn></mrow>         <mi>n</mi>        </munderover>        <mrow>         <mrow><mo>(</mo>          <mrow>           <mtable>            <mtr>             <mtd>              <mi>x</mi>             </mtd>            </mtr>            <mtr>             <mtd>              <mi>k</mi>             </mtd>            </mtr>           </mtable></mrow>         <mo>)</mo></mrow></mrow>       </mstyle><msub>        <mi>D</mi>        <mi>k</mi>       </msub>       <mo>=</mo><mstyle displaystyle="true">        <munderover>         <mo>&#x2211;</mo>         <mrow>          <mi>k</mi><mo>=</mo><mn>0</mn></mrow>         <mi>n</mi>        </munderover>        <mrow>         <mfrac>          <mrow>           <msub>            <mrow>             <mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow>            <mi>k</mi>           </msub>           </mrow>          <mrow>           <mi>&#x0393;</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>         </mfrac>         </mrow>       </mstyle><msup>        <mi>D</mi>        <mi>k</mi>       </msup>       <mo>=</mo><mstyle displaystyle="true">        <munderover>         <mo>&#x2211;</mo>         <mrow>          <mi>k</mi><mo>=</mo><mn>0</mn></mrow>         <mi>n</mi>        </munderover>        <mrow>         <mstyle displaystyle="true">          <munderover>           <mo>&#x2211;</mo>           <mrow>            <mi>i</mi><mo>=</mo><mi>k</mi></mrow>           <mi>n</mi>          </munderover>          <mrow>           <mfrac>            <mrow>             <mrow><mo>[</mo> <mrow>              <mtable>               <mtr>                <mtd>                 <mi>i</mi>                </mtd>               </mtr>               <mtr>                <mtd>                 <mi>k</mi>                </mtd>               </mtr>              </mtable></mrow> <mo>]</mo></mrow></mrow>            <mrow>             <mi>&#x0393;</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>           </mfrac>           </mrow>         </mstyle></mrow>       </mstyle><msup>        <mi>D</mi>        <mi>i</mi>       </msup>       <msup>        <mi>x</mi>        <mi>k</mi>       </msup>       <mo>,</mo></mrow>     </mtd>    </mtr>    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <msub>        <mi>Q</mi>        <mi>n</mi>       </msub>       <mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mstyle displaystyle="true">        <munderover>         <mo>&#x2211;</mo>         <mrow>          <mi>k</mi><mo>=</mo><mn>0</mn></mrow>         <mi>n</mi>        </munderover>        <mrow>         <mfrac>          <mrow>           <msub>            <mrow>             <mo>&#x2329;</mo><mi>x</mi><mo>&#x232A;</mo></mrow>            <mi>k</mi>           </msub>           </mrow>          <mrow>           <mi>&#x0393;</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>         </mfrac>         </mrow>       </mstyle><msup>        <mi>D</mi>        <mi>k</mi>       </msup>       <mo>=</mo><mstyle displaystyle="true">        <munderover>         <mo>&#x2211;</mo>         <mrow>          <mi>k</mi><mo>=</mo><mn>0</mn></mrow>         <mi>n</mi>        </munderover>        <mrow>         <mstyle displaystyle="true">          <munderover>           <mo>&#x2211;</mo>           <mrow>            <mi>i</mi><mo>=</mo><mi>k</mi></mrow>           <mi>n</mi>          </munderover>          <mrow>           <msup>            <mrow>             <mo stretchy="false">(</mo><mo>&#x2212;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>            <mrow>             <mi>i</mi><mo>+</mo><mi>k</mi></mrow>           </msup>           </mrow>         </mstyle></mrow>       </mstyle><mfrac>        <mrow>         <mrow><mo>[</mo> <mrow>          <mtable>           <mtr>            <mtd>             <mi>i</mi>            </mtd>           </mtr>           <mtr>            <mtd>             <mi>k</mi>            </mtd>           </mtr>          </mtable></mrow> <mo>]</mo></mrow></mrow>        <mrow>         <mi>&#x0393;</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>       </mfrac>       <msup>        <mi>D</mi>        <mi>i</mi>       </msup>       <msup>        <mi>x</mi>        <mi>k</mi>       </msup>       </mrow>     </mtd>    </mtr>   </mtable></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaafaqaaeGabaaabaaeaaaaaaaaa8qacaWG  qbWdamaaBaaaleaapeGaamOBaaWdaeqaaOWdbiaacUfacaWG4bGaai  yxaiabg2da9maaqahapaqaa8qadaqadaWdaeaafaqabeGabaaabaWd  biaadIhaa8aabaWdbiaadUgaaaaacaGLOaGaayzkaaaal8aabaWdbi  aadUgacqGH9aqpcaaIWaaapaqaa8qacaWGUbaaniabggHiLdGccaWG  ebWdamaaBaaaleaapeGaam4AaaWdaeqaaOWdbiabg2da9maaqahapa  qaa8qadaWcaaWdaeaapeGaaiikaiaadIhacaGGPaWdamaaBaaaleaa  peGaam4AaaWdaeqaaaGcbaWdbiabfo5ahjaacIcacaWGRbGaey4kaS  IaaGymaiaacMcaaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaapaqa  a8qacaWGUbaaniabggHiLdGccaWGebWdamaaCaaaleqabaWdbiaadU  gaaaGccqGH9aqpdaaeWbWdaeaapeWaaabCa8aabaWdbmaalaaapaqa  a8qadaWadaWdaeaafaqabeGabaaabaWdbiaadMgaa8aabaWdbiaadU  gaaaaacaGLBbGaayzxaaaapaqaa8qacqqHtoWrcaGGOaGaamyAaiab  gUcaRiaaigdacaGGPaaaaaWcpaqaa8qacaWGPbGaeyypa0Jaam4Aaa  WdaeaapeGaamOBaaqdcqGHris5aaWcpaqaa8qacaWGRbGaeyypa0Ja  aGimaaWdaeaapeGaamOBaaqdcqGHris5aOGaamira8aadaahaaWcbe  qaa8qacaWGPbaaaOGaamiEa8aadaahaaWcbeqaa8qacaWGRbaaaOGa  aiilaaWdaeaapeGaamyua8aadaWgaaWcbaWdbiaad6gaa8aabeaak8  qacaGGBbGaamiEaiaac2facqGH9aqpdaaeWbWdaeaapeWaaSaaa8aa  baWdbiabgMYiHlaadIhacqGHQms8paWaaSbaaSqaa8qacaWGRbaapa  qabaaakeaapeGaeu4KdCKaaiikaiaadUgacqGHRaWkcaaIXaGaaiyk  aaaaaSWdaeaapeGaam4Aaiabg2da9iaaicdaa8aabaWdbiaad6gaa0  GaeyyeIuoakiaadseapaWaaWbaaSqabeaapeGaam4Aaaaakiabg2da  9maaqahapaqaa8qadaaeWbWdaeaapeGaaiikaiabgkHiTiaaigdaca  GGPaWdamaaCaaaleqabaWdbiaadMgacqGHRaWkcaWGRbaaaaWdaeaa  peGaamyAaiabg2da9iaadUgaa8aabaWdbiaad6gaa0GaeyyeIuoaaS  WdaeaapeGaam4Aaiabg2da9iaaicdaa8aabaWdbiaad6gaa0Gaeyye  Iuoakmaalaaapaqaa8qadaWadaWdaeaafaqabeGabaaabaWdbiaadM  gaa8aabaWdbiaadUgaaaaacaGLBbGaayzxaaaapaqaa8qacqqHtoWr  caGGOaGaamyAaiabgUcaRiaaigdacaGGPaaaaiaadseapaWaaWbaaS  qabeaapeGaamyAaaaakiaadIhapaWaaWbaaSqabeaapeGaam4Aaaaa  aaaaaa@BC36@  </annotation> </semantics></math><p>其中$\left[ {\begin{array}{*{20}{c}}n\\k\end{array}} \right]$是第一类无符号Stirling数。</p><ul><li><strong>定理2</strong></li></ul><p>$\forall x,y \in \mathbb{R}$，则有$\begin{array}{l}P_n[x + y] = P_n[x]P_n[y],\\{Q_n}[x + y] = {Q_n}[x]{Q_n}[y].\end{array}$</p><p>证明：当$i \geq j$时，</p><math display="block"> <semantics>  <mrow>   <msub>    <mrow>     <mo stretchy="false">(</mo><msub>      <mi>P</mi>      <mi>n</mi>     </msub>     <mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><msub>      <mi>P</mi>      <mi>n</mi>     </msub>     <mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow>    <mrow>     <mi>i</mi><mi>j</mi></mrow>   </msub>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mi>j</mi></mrow>     <mi>i</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>i</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mi>y</mi>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <mi>k</mi><mo>&#x2212;</mo><mi>j</mi></mrow>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>x</mi><mo>+</mo><mi>y</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><mo>=</mo><msub>    <mrow>     <mo stretchy="false">(</mo><msub>      <mi>P</mi>      <mi>n</mi>     </msub>     <mo stretchy="false">[</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow>    <mrow>     <mi>i</mi><mi>j</mi></mrow>   </msub>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbiaacIcacaWGqbWdamaa  BaaaleaapeGaamOBaaWdaeqaaOWdbiaacUfacaWG4bGaaiyxaiaadc  fapaWaaSbaaSqaa8qacaWGUbaapaqabaGcpeGaai4waiaadMhacaGG  DbGaaiyka8aadaWgaaWcbaWdbiaadMgacaWGQbaapaqabaGcpeGaey  ypa0ZaaabCa8aabaWdbmaabmaapaqaauaabeqaceaaaeaapeGaamiE  aaWdaeaapeGaamyAaiabgkHiTiaadUgaaaaacaGLOaGaayzkaaaal8  aabaWdbiaadUgacqGH9aqpcaWGQbaapaqaa8qacaWGPbaaniabggHi  LdGcdaqadaWdaeaafaqabeGabaaabaWdbiaadMhaa8aabaWdbiaadU  gacqGHsislcaWGQbaaaaGaayjkaiaawMcaaiabg2da9maabmaapaqa  auaabeqaceaaaeaapeGaamiEaiabgUcaRiaadMhaa8aabaWdbiaadM  gacqGHsislcaWGQbaaaaGaayjkaiaawMcaaiabg2da9iaacIcacaWG  qbWdamaaBaaaleaapeGaamOBaaWdaeqaaOWdbiaacUfacaWG4bGaey  4kaSIaamyEaiaac2facaGGPaWdamaaBaaaleaapeGaamyAaiaadQga  a8aabeaaaaa@7385@  </annotation> </semantics></math><p><em>推论</em>：$\forall x,y \in \mathbb{R},m \in \mathbb{Z}$，有$\begin{array}{l}P_n{[x]^{ - 1}} = P_n[ - x],\\P_n{[x]^m} = P_n[mx],\\P_n[x] = P_n{[\frac{x}{m}]^m}.\end{array}$</p><ul><li><strong>定义2</strong></li></ul><p>$\forall x,y \in \mathbb{R}$,$n+1$阶矩阵$P_n[x,y],Q_n[x,y]$分别定义为</p><math display="block"> <semantics>  <mrow>   <mtable columnalign="left">    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <msub>        <mrow>         <mo stretchy="false">(</mo><msub>          <mi>P</mi>          <mi>n</mi>         </msub>         <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow>        <mrow>         <mi>i</mi><mi>j</mi></mrow>       </msub>       <mo>=</mo><mrow><mo>{</mo> <mrow>        <mtable>         <mtr>          <mtd>           <mrow>            <mrow><mo>(</mo>             <mrow>              <mtable>               <mtr>                <mtd>                 <mi>x</mi>                </mtd>               </mtr>               <mtr>                <mtd>                 <mrow>                  <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>                </mtd>               </mtr>              </mtable></mrow>            <mo>)</mo></mrow><msup>             <mi>y</mi>             <mrow>              <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>            </msup>            </mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mn>0</mn>          </mtd>         </mtr>        </mtable></mrow> </mrow><mo>,</mo><mi>i</mi><mo>&#x2265;</mo><mi>j</mi><mo>;</mo></mrow>     </mtd>    </mtr>    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <msub>        <mrow>         <mo stretchy="false">(</mo><msub>          <mi>Q</mi>          <mi>n</mi>         </msub>         <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow>        <mrow>         <mi>i</mi><mi>j</mi></mrow>       </msub>       <mo>=</mo><mrow><mo>{</mo> <mrow>        <mtable>         <mtr>          <mtd>           <mrow>            <mrow><mo>&#x2329;</mo> <mrow>             <mtable>              <mtr>               <mtd>                <mi>x</mi>               </mtd>              </mtr>              <mtr>               <mtd>                <mrow>                 <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>               </mtd>              </mtr>             </mtable></mrow> <mo>&#x232A;</mo></mrow><msup>             <mi>y</mi>             <mrow>              <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>            </msup>            </mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mn>0</mn>          </mtd>         </mtr>        </mtable></mrow> </mrow><mo>,</mo><mi>i</mi><mo>&#x2265;</mo><mi>j</mi><mo>.</mo></mrow>     </mtd>    </mtr>   </mtable></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaafaqaaeGabaaabaaeaaaaaaaaa8qacaGG  OaGaamiua8aadaWgaaWcbaWdbiaad6gaa8aabeaak8qacaGGBbGaam  iEaiaacYcacaWG5bGaaiyxaiaacMcapaWaaSbaaSqaa8qacaWGPbGa  amOAaaWdaeqaaOWdbiabg2da9maaceaapaqaauaabeqaceaaaeaape  WaaeWaa8aabaqbaeqabiqaaaqaa8qacaWG4baapaqaa8qacaWGPbGa  eyOeI0IaamOAaaaaaiaawIcacaGLPaaacaWG5bWdamaaCaaaleqaba  WdbiaadMgacqGHsislcaWGQbaaaaGcpaqaa8qacaaIWaaaaaGaay5E  aaGaaiilaiaadMgacqGHLjYScaWGQbGaai4oaaWdaeaapeGaaiikai  aadgfapaWaaSbaaSqaa8qacaWGUbaapaqabaGcpeGaai4waiaadIha  caGGSaGaamyEaiaac2facaGGPaWdamaaBaaaleaapeGaamyAaiaadQ  gaa8aabeaak8qacqGH9aqpdaGabaWdaeaafaqabeGabaaabaWdbmaa  amaapaqaauaabeqaceaaaeaapeGaamiEaaWdaeaapeGaamyAaiabgk  HiTiaadQgaaaaacaGLPmIaayPkJaGaamyEa8aadaahaaWcbeqaa8qa  caWGPbGaeyOeI0IaamOAaaaaaOWdaeaapeGaaGimaaaaaiaawUhaai  aacYcacaWGPbGaeyyzImRaamOAaiaac6caaaaaaa@7824@  </annotation> </semantics></math><ul><li><strong>定理3</strong></li></ul><p>$\forall x,y,z \in \mathbb{R}, m \in \mathbb{Z}$，有</p><math display="block"> <semantics>  <mrow>   <mtable columnalign="left">    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <mrow><mo>{</mo> <mrow>        <mtable>         <mtr>          <mtd>           <mrow>            <msub>             <mi>P</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">]</mo><msub>             <mi>P</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">]</mo><mo>=</mo><msub>             <mi>P</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">]</mo><mo>,</mo></mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mrow>            <msub>             <mi>Q</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">]</mo><msub>             <mi>Q</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">]</mo><mo>=</mo><msub>             <mi>Q</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">]</mo><mo>.</mo></mrow>          </mtd>         </mtr>        </mtable></mrow> </mrow></mrow>     </mtd>    </mtr>    <mtr columnalign="left">     <mtd columnalign="left">      <mrow>       <mrow><mo>{</mo> <mrow>        <mtable>         <mtr>          <mtd>           <mrow>            <msub>             <mi>P</mi>             <mi>n</mi>            </msub>            <msup>             <mrow>              <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow>             <mi>m</mi>            </msup>            <mo>=</mo><msub>             <mi>P</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>m</mi><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>,</mo></mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mrow>            <msub>             <mi>Q</mi>             <mi>n</mi>            </msub>            <msup>             <mrow>              <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow>             <mi>m</mi>            </msup>            <mo>=</mo><msub>             <mi>Q</mi>             <mi>n</mi>            </msub>            <mo stretchy="false">[</mo><mi>m</mi><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>.</mo></mrow>          </mtd>         </mtr>        </mtable></mrow> </mrow></mrow>     </mtd>    </mtr>   </mtable></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaafaqaaeGabaaabaaeaaaaaaaaa8qadaGa  baWdaeaafaqabeGabaaabaWdbiaadcfapaWaaSbaaSqaa8qacaWGUb  aapaqabaGcpeGaai4waiaadIhacaGGSaGaamOEaiaac2facaWGqbWd  amaaBaaaleaapeGaamOBaaWdaeqaaOWdbiaacUfacaWG5bGaaiilai  aadQhacaGGDbGaeyypa0Jaamiua8aadaWgaaWcbaWdbiaad6gaa8aa  beaak8qacaGGBbGaamiEaiabgUcaRiaadMhacaGGSaGaamOEaiaac2  facaGGSaaapaqaa8qacaWGrbWdamaaBaaaleaapeGaamOBaaWdaeqa  aOWdbiaacUfacaWG4bGaaiilaiaadQhacaGGDbGaamyua8aadaWgaa  WcbaWdbiaad6gaa8aabeaak8qacaGGBbGaamyEaiaacYcacaWG6bGa  aiyxaiabg2da9iaadgfapaWaaSbaaSqaa8qacaWGUbaapaqabaGcpe  Gaai4waiaadIhacqGHRaWkcaWG5bGaaiilaiaadQhacaGGDbGaaiOl  aaaaaiaawUhaaaWdaeaapeWaaiqaa8aabaqbaeqabiqaaaqaa8qaca  WGqbWdamaaBaaaleaapeGaamOBaaWdaeqaaOWdbiaacUfacaWG4bGa  aiilaiaadMhacaGGDbWdamaaCaaaleqabaWdbiaad2gaaaGccqGH9a  qpcaWGqbWdamaaBaaaleaapeGaamOBaaWdaeqaaOWdbiaacUfacaWG  TbGaamiEaiaacYcacaWG5bGaaiyxaiaacYcaa8aabaWdbiaadgfapa  WaaSbaaSqaa8qacaWGUbaapaqabaGcpeGaai4waiaadIhacaGGSaGa  amyEaiaac2fapaWaaWbaaSqabeaapeGaamyBaaaakiabg2da9iaadg  fapaWaaSbaaSqaa8qacaWGUbaapaqabaGcpeGaai4waiaad2gacaWG  4bGaaiilaiaadMhacaGGDbGaaiOlaaaaaiaawUhaaaaaaaa@93D4@  </annotation> </semantics></math><p>即</p><math display="block"> <semantics>  <mrow>   <mrow><mo>{</mo> <mrow>    <mtable>     <mtr>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mi>n</mi>        </msub>        <msup>         <mrow>          <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow>         <mrow>          <mo>&#x2212;</mo><mn>1</mn></mrow>        </msup>        <mo>=</mo><msub>         <mi>P</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mo>&#x2212;</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>,</mo><msub>         <mi>P</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><msub>         <mi>P</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>,</mo><msub>         <mi>P</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><msub>         <mi>I</mi>         <mrow>          <mi>n</mi><mo>+</mo><mn>1</mn></mrow>        </msub>        <mo>;</mo></mrow>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <msub>         <mi>Q</mi>         <mi>n</mi>        </msub>        <msup>         <mrow>          <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow>         <mrow>          <mo>&#x2212;</mo><mn>1</mn></mrow>        </msup>        <mo>=</mo><msub>         <mi>Q</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mo>&#x2212;</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>,</mo><msub>         <mi>Q</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><msub>         <mi>Q</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>,</mo><msub>         <mi>Q</mi>         <mi>n</mi>        </msub>        <mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><msub>         <mi>I</mi>         <mrow>          <mi>n</mi><mo>+</mo><mn>1</mn></mrow>        </msub>        <mo>.</mo></mrow>      </mtd>     </mtr>    </mtable></mrow> </mrow></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaceaapaqaauaabeqa  ceaaaeaapeGaamiua8aadaWgaaWcbaWdbiaad6gaa8aabeaak8qaca  GGBbGaamiEaiaacYcacaWG5bGaaiyxa8aadaahaaWcbeqaa8qacqGH  sislcaaIXaaaaOGaeyypa0Jaamiua8aadaWgaaWcbaWdbiaad6gaa8  aabeaak8qacaGGBbGaeyOeI0IaamiEaiaacYcacaWG5bGaaiyxaiaa  cYcacaWGqbWdamaaBaaaleaapeGaamOBaaWdaeqaaOWdbiaacUfaca  WG4bGaaiilaiaaigdacaGGDbGaeyypa0Jaamiua8aadaWgaaWcbaWd  biaad6gaa8aabeaak8qacaGGBbGaamiEaiaac2facaGGSaGaamiua8  aadaWgaaWcbaWdbiaad6gaa8aabeaak8qacaGGBbGaaGimaiaacYca  caaIXaGaaiyxaiabg2da9iaadMeapaWaaSbaaSqaa8qacaWGUbGaey  4kaSIaaGymaaWdaeqaaOWdbiaacUdaa8aabaWdbiaadgfapaWaaSba  aSqaa8qacaWGUbaapaqabaGcpeGaai4waiaadIhacaGGSaGaamyEai  aac2fapaWaaWbaaSqabeaapeGaeyOeI0IaaGymaaaakiabg2da9iaa  dgfapaWaaSbaaSqaa8qacaWGUbaapaqabaGcpeGaai4waiabgkHiTi  aadIhacaGGSaGaamyEaiaac2facaGGSaGaamyua8aadaWgaaWcbaWd  biaad6gaa8aabeaak8qacaGGBbGaamiEaiaacYcacaaIXaGaaiyxai  abg2da9iaadgfapaWaaSbaaSqaa8qacaWGUbaapaqabaGcpeGaai4w  aiaadIhacaGGDbGaaiilaiaadgfapaWaaSbaaSqaa8qacaWGUbaapa  qabaGcpeGaai4waiaaicdacaGGSaGaaGymaiaac2facqGH9aqpcaWG  jbWdamaaBaaaleaapeGaamOBaiabgUcaRiaaigdaa8aabeaak8qaca  GGUaaaaaGaay5Eaaaaaa@960D@  </annotation> </semantics></math><h3 id="反演开始！"><a href="#反演开始！" class="headerlink" title="反演开始！"></a>反演开始！</h3><p>还记得上面的推论吗？我们由它可以得到如下定理：</p><ul><li><strong>定理4</strong></li></ul><p>$\forall x,y \in \mathbb{R}​$，设$\{a_n\}_{n\geq 0}=\{a_n(x,y)\}_{n\geq 0}​$和$\{b_n\}_{n\geq 0}=\{b_n(x,y)\}_{n\geq 0}​$为两个函数序列</p><p>那么我们有</p><math display="block"> <semantics>  <mrow>   <msub>    <mi>a</mi>    <mi>n</mi>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msub>    <mi>b</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&#x21D4;</mo><msub>    <mi>b</mi>    <mi>n</mi>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mo>&#x2212;</mo><mi>x</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msub>    <mi>a</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbiaadggapaWaaSbaaSqa  a8qacaWGUbaapaqabaGcpeGaaiikaiaadIhacaGGSaGaamyEaiaacM  cacqGH9aqpdaaeWbWdaeaapeWaaeWaa8aabaqbaeqabiqaaaqaa8qa  caWG4baapaqaa8qacaWGRbaaaaGaayjkaiaawMcaaaWcpaqaa8qaca  WGRbGaeyypa0JaaGimaaWdaeaapeGaamOBaaqdcqGHris5aOGaamOy  a8aadaWgaaWcbaWdbiaad6gacqGHsislcaWGRbaapaqabaGcpeGaai  ikaiaadIhacaGGSaGaamyEaiaacMcacqGHuhY2caWGIbWdamaaBaaa  leaapeGaamOBaaWdaeqaaOWdbiaacIcacaWG4bGaaiilaiaadMhaca  GGPaGaeyypa0ZaaabCa8aabaWdbmaabmaapaqaauaabeqaceaaaeaa  peGaeyOeI0IaamiEaaWdaeaapeGaamOBaiabgkHiTiaadUgaaaaaca  GLOaGaayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaapaqaa8qa  caWGUbaaniabggHiLdGccaWGHbWdamaaBaaaleaapeGaamOBaiabgk  HiTiaadUgaa8aabeaak8qacaGGOaGaamiEaiaacYcacaWG5bGaaiyk  aaaa@778B@  </annotation> </semantics></math><p>也就是</p><math display="block"> <semantics>  <mrow>   <msub>    <mi>a</mi>    <mi>n</mi>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msub>    <mi>b</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&#x21D4;</mo><msub>    <mi>b</mi>    <mi>n</mi>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mo>&#x2212;</mo><mi>x</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msub>    <mi>a</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msub>   <mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbiaadggapaWaaSbaaSqa  a8qacaWGUbaapaqabaGcpeGaaiikaiaadIhacaGGSaGaamyEaiaacM  cacqGH9aqpdaaeWbWdaeaapeWaaeWaa8aabaqbaeqabiqaaaqaa8qa  caWG4baapaqaa8qacaWGUbGaeyOeI0Iaam4AaaaaaiaawIcacaGLPa  aaaSWdaeaapeGaam4Aaiabg2da9iaaicdaa8aabaWdbiaad6gaa0Ga  eyyeIuoakiaadkgapaWaaSbaaSqaa8qacaWGUbGaeyOeI0Iaam4Aaa  WdaeqaaOWdbiaacIcacaWG4bGaaiilaiaadMhacaGGPaGaeyi1HSTa  amOya8aadaWgaaWcbaWdbiaad6gaa8aabeaak8qacaGGOaGaamiEai  aacYcacaWG5bGaaiykaiabg2da9maaqahapaqaa8qadaqadaWdaeaa  faqabeGabaaabaWdbiabgkHiTiaadIhaa8aabaWdbiaad6gacqGHsi  slcaWGRbaaaaGaayjkaiaawMcaaaWcpaqaa8qacaWGRbGaeyypa0Ja  aGimaaWdaeaapeGaamOBaaqdcqGHris5aOGaamyya8aadaWgaaWcba  Wdbiaad6gacqGHsislcaWGRbaapaqabaGcpeGaaiikaiaadIhacaGG  SaGaamyEaiaacMcaaaa@796B@  </annotation> </semantics></math><p><strong>证明</strong>：</p><p>设$a = {({a_0},{a_1}, \cdots ,{a_n})^T},b = {({b_0},{b_1}, \cdots ,{b_n})^T}$，注意到$a = P_n[x] \Leftrightarrow b = P_n[ - x]$</p><p>即</p><math display="block"> <semantics>  <mrow>   <msub>    <mi>a</mi>    <mi>i</mi>   </msub>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>j</mi><mo>=</mo><mn>0</mn></mrow>     <mi>i</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msub>    <mi>b</mi>    <mi>j</mi>   </msub>   <mo>&#x21D4;</mo><msub>    <mi>b</mi>    <mi>i</mi>   </msub>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>j</mi><mo>=</mo><mn>0</mn></mrow>     <mi>i</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mo>&#x2212;</mo><mi>x</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>i</mi><mo>&#x2212;</mo><mi>j</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msub>    <mi>a</mi>    <mi>j</mi>   </msub>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbiaadggapaWaaSbaaSqa  a8qacaWGPbaapaqabaGcpeGaeyypa0ZaaabCa8aabaWdbmaabmaapa  qaauaabeqaceaaaeaapeGaamiEaaWdaeaapeGaamyAaiabgkHiTiaa  dQgaaaaacaGLOaGaayzkaaaal8aabaWdbiaadQgacqGH9aqpcaaIWa  aapaqaa8qacaWGPbaaniabggHiLdGccaWGIbWdamaaBaaaleaapeGa  amOAaaWdaeqaaOWdbiabgsDiBlaadkgapaWaaSbaaSqaa8qacaWGPb  aapaqabaGcpeGaeyypa0ZaaabCa8aabaWdbmaabmaapaqaauaabeqa  ceaaaeaapeGaeyOeI0IaamiEaaWdaeaapeGaamyAaiabgkHiTiaadQ  gaaaaacaGLOaGaayzkaaaal8aabaWdbiaadQgacqGH9aqpcaaIWaaa  paqaa8qacaWGPbaaniabggHiLdGccaWGHbWdamaaBaaaleaapeGaam  OAaaWdaeqaaaaa@655D@  </annotation> </semantics></math><p>我们的二项式反演公式也就很明白了：</p><p>令${\{ {a_n}\} _{n \ge 0}}$和${\{ {b_n}\} _{n \ge 0}}$是两个数列，$s$为非负整数，$\forall  n \geq s$，有</p><script type="math/tex; mode=display">{a_n} = \mathop \sum \limits_{k = s}^n \left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right){b_k}</script><p>则有</p><script type="math/tex; mode=display">{b_n} = \mathop \sum \limits_{k = s}^n {( - 1)^{n - k}}\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right){a_k}</script><p>好啦~ 反演到此为止，下面是娱乐环节！</p><h2 id="一些神奇的恒等式变换"><a href="#一些神奇的恒等式变换" class="headerlink" title="一些神奇的恒等式变换"></a>一些神奇的恒等式变换</h2><ul><li>如果你连基本恒等式都看不懂，说明你需要补习数学。</li></ul><h3 id="神奇变换1"><a href="#神奇变换1" class="headerlink" title="神奇变换1"></a>神奇变换1</h3><p>有恒等式</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msup>    <mi>y</mi>    <mi>k</mi>   </msup>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>x</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msup>    <mrow>     <mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msup>   <msup>    <mrow>     <mo stretchy="false">(</mo><mo>&#x2212;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow>    <mi>k</mi>   </msup>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiaadIhaa8aabaWdbiaadUgaaaaaca  GLOaGaayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaapaqaa8qa  caWGUbaaniabggHiLdGccaWG5bWdamaaCaaaleqabaWdbiaadUgaaa  GccqGH9aqpdaaeWbWdaeaapeWaaeWaa8aabaqbaeqabiqaaaqaa8qa  caWGUbGaeyOeI0IaamiEaaWdaeaapeGaam4AaaaaaiaawIcacaGLPa  aaaSWdaeaapeGaam4Aaiabg2da9iaaicdaa8aabaWdbiaad6gaa0Ga  eyyeIuoakiaacIcacaaIXaGaey4kaSIaamyEaiaacMcapaWaaWbaaS  qabeaapeGaamOBaiabgkHiTiaadUgaaaGccaGGOaGaeyOeI0IaamyE  aiaacMcapaWaaWbaaSqabeaapeGaam4Aaaaaaaa@641A@  </annotation> </semantics></math><p>作变换：</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msup>    <mi>y</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msup>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <msup>      <mrow>       <mo stretchy="false">(</mo><mo>&#x2212;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow>      <mi>k</mi>     </msup>     </mrow>   </mstyle><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>n</mi><mo>&#x2212;</mo><mi>x</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>k</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><msup>    <mrow>     <mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msup>   <mo>&#x22EF;</mo><mo>&#x22EF;</mo><mtext>Tip</mtext><mo>:</mo><mtext>replace&#x00A0;</mtext><mtext>&#x2009;</mtext><mi>y</mi><mtext>&#x2009;</mtext><mtext>with</mtext><mtext>&#x2009;</mtext><mfrac>    <mn>1</mn>    <mi>y</mi>   </mfrac>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiaadIhaa8aabaWdbiaadUgaaaaaca  GLOaGaayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaapaqaa8qa  caWGUbaaniabggHiLdGccaWG5bWdamaaCaaaleqabaWdbiaad6gacq  GHsislcaWGRbaaaOGaeyypa0ZaaabCa8aabaWdbiaacIcacqGHsisl  caWG4bGaaiyka8aadaahaaWcbeqaa8qacaWGRbaaaaWdaeaapeGaam  4Aaiabg2da9iaaicdaa8aabaWdbiaad6gaa0GaeyyeIuoakmaabmaa  paqaauaabeqaceaaaeaapeGaamOBaiabgkHiTiaadIhaa8aabaWdbi  aadUgaaaaacaGLOaGaayzkaaGaaiikaiaaigdacqGHRaWkcaWG5bGa  aiyka8aadaahaaWcbeqaa8qacaWGUbGaeyOeI0Iaam4Aaaaakiabl+  Uimjabl+UimjaabsfacaqGPbGaaeiCaiaacQdacaqGYbGaaeyzaiaa  bchacaqGSbGaaeyyaiaabogacaqGLbGaaeiia8aacaaMe8+dbiaadM  hapaGaaGjbVlaabEhacaqGPbGaaeiDaiaabIgacaaMe8+dbmaalaaa  paqaa8qacaaIXaaapaqaa8qacaWG5baaaaaa@8004@  </annotation> </semantics></math><p>令</p><math display="block"> <semantics>  <mrow>   <msub>    <mi>b</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msub>   <mo>=</mo><msup>    <mi>y</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msup>   <mo>,</mo><msub>    <mi>a</mi>    <mi>n</mi>   </msub>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <msup>      <mrow>       <mo stretchy="false">(</mo><mo>&#x2212;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>      <mi>k</mi>     </msup>     </mrow>   </mstyle><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>n</mi><mo>&#x2212;</mo><mi>x</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>k</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><msup>    <mrow>     <mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </msup>   <mo>,</mo></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbiaadkgapaWaaSbaaSqa  a8qacaWGUbGaeyOeI0Iaam4AaaWdaeqaaOWdbiabg2da9iaadMhapa  WaaWbaaSqabeaapeGaamOBaiabgkHiTiaadUgaaaGccaGGSaGaamyy  a8aadaWgaaWcbaWdbiaad6gaa8aabeaak8qacqGH9aqpdaaeWbWdae  aapeGaaiikaiabgkHiTiaaigdacaGGPaWdamaaCaaaleqabaWdbiaa  dUgaaaaapaqaa8qacaWGRbGaeyypa0JaaGimaaWdaeaapeGaamOBaa  qdcqGHris5aOWaaeWaa8aabaqbaeqabiqaaaqaa8qacaWGUbGaeyOe  I0IaamiEaaWdaeaapeGaam4AaaaaaiaawIcacaGLPaaacaGGOaGaaG  ymaiabgUcaRiaadMhacaGGPaWdamaaCaaaleqabaWdbiaad6gacqGH  sislcaWGRbaaaOGaaiilaaaa@647D@  </annotation> </semantics></math><p>则有</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mstyle displaystyle="true">      <munderover>       <mo>&#x2211;</mo>       <mrow>        <mi>i</mi><mo>=</mo><mn>0</mn></mrow>       <mrow>        <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>      </munderover>      <mrow>       <msup>        <mrow>         <mo stretchy="false">(</mo><mo>&#x2212;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>        <mi>i</mi>       </msup>       </mrow>     </mstyle></mrow>   </mstyle><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <mo>&#x2212;</mo><mi>x</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>k</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>n</mi><mo>&#x2212;</mo><mi>k</mi><mo>&#x2212;</mo><mi>x</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>i</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><msup>    <mrow>     <mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi><mo>&#x2212;</mo><mi>i</mi></mrow>   </msup>   <mo>=</mo><msup>    <mi>y</mi>    <mi>n</mi>   </msup>   <mo>&#x22EF;</mo><mo>&#x22EF;</mo><mtext>Tip</mtext><mo>:</mo><mtext>Use</mtext><mtext>&#x2009;</mtext><mtext>the&#x00A0;Inversion&#x00A0;Formula</mtext></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaae  WbWdaeaapeGaaiikaiabgkHiTiaaigdacaGGPaWdamaaCaaaleqaba  WdbiaadMgaaaaapaqaa8qacaWGPbGaeyypa0JaaGimaaWdaeaapeGa  amOBaiabgkHiTiaadUgaa0GaeyyeIuoaaSWdaeaapeGaam4Aaiabg2  da9iaaicdaa8aabaWdbiaad6gaa0GaeyyeIuoakmaabmaapaqaauaa  beqaceaaaeaapeGaeyOeI0IaamiEaaWdaeaapeGaam4AaaaaaiaawI  cacaGLPaaadaqadaWdaeaafaqabeGabaaabaWdbiaad6gacqGHsisl  caWGRbGaeyOeI0IaamiEaaWdaeaapeGaamyAaaaaaiaawIcacaGLPa  aacaGGOaGaaGymaiabgUcaRiaadMhacaGGPaWdamaaCaaaleqabaWd  biaad6gacqGHsislcaWGRbGaeyOeI0IaamyAaaaakiabg2da9iaadM  hapaWaaWbaaSqabeaapeGaamOBaaaakiabl+Uimjabl+Uimjaabsfa  caqGPbGaaeiCaiaacQdacaqGvbGaae4CaiaabwgapaGaaGjbV=qaca  qG0bGaaeiAaiaabwgacaqGGaGaaeysaiaab6gacaqG2bGaaeyzaiaa  bkhacaqGZbGaaeyAaiaab+gacaqGUbGaaeiiaiaabAeacaqGVbGaae  OCaiaab2gacaqG1bGaaeiBaiaabggaaaa@88C6@  </annotation> </semantics></math><h3 id="神奇变换2"><a href="#神奇变换2" class="headerlink" title="神奇变换2"></a>神奇变换2</h3><p>有恒等式</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <msup>      <mrow>       <mo stretchy="false">(</mo><mo>&#x2212;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>      <mi>k</mi>     </msup>     </mrow>   </mstyle><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>n</mi><mo>+</mo><mi>x</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><mfrac>    <mn>1</mn>    <mrow>     <mn>1</mn><mo>+</mo><mi>k</mi></mrow>   </mfrac>   <mo>=</mo><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <msub>          <mi>B</mi>          <mi>n</mi>         </msub>         <mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>n</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qacaGG  OaGaeyOeI0IaaGymaiaacMcapaWaaWbaaSqabeaapeGaam4Aaaaaa8  aabaWdbiaadUgacqGH9aqpcaaIWaaapaqaa8qacaWGUbaaniabggHi  LdGcdaqadaWdaeaafaqabeGabaaabaWdbiaad6gacqGHRaWkcaWG4b  aapaqaa8qacaWGUbGaeyOeI0Iaam4AaaaaaiaawIcacaGLPaaadaWc  aaWdaeaapeGaaGymaaWdaeaapeGaaGymaiabgUcaRiaadUgaaaGaey  ypa0ZaaeWaa8aabaqbaeqabiqaaaqaa8qacaWGcbWdamaaBaaaleaa  peGaamOBaaWdaeqaaOWdbiaacIcacaWG4bGaaiykaiabgUcaRiaad6  gaa8aabaWdbiaad6gaaaaacaGLOaGaayzkaaaaaa@5EEC@  </annotation> </semantics></math><p>，其中$B_n(x)$是Bernouli多项式</p><p>变形为：</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>x</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mfrac>    <mrow>     <msup>      <mrow>       <mo stretchy="false">(</mo><mo>&#x2212;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>      <mi>k</mi>     </msup>     </mrow>    <mrow>     <mn>1</mn><mo>+</mo><mi>k</mi></mrow>   </mfrac>   <mo>=</mo><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <msub>          <mi>B</mi>          <mi>n</mi>         </msub>         <mo stretchy="false">(</mo><mi>x</mi><mo>&#x2212;</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>n</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow></mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiaadIhaa8aabaWdbiaad6gacqGHsi  slcaWGRbaaaaGaayjkaiaawMcaaaWcpaqaa8qacaWGRbGaeyypa0Ja  aGimaaWdaeaapeGaamOBaaqdcqGHris5aOWaaSaaa8aabaWdbiaacI  cacqGHsislcaaIXaGaaiyka8aadaahaaWcbeqaa8qacaWGRbaaaaGc  paqaa8qacaaIXaGaey4kaSIaam4AaaaacqGH9aqpdaqadaWdaeaafa  qabeGabaaabaWdbiaadkeapaWaaSbaaSqaa8qacaWGUbaapaqabaGc  peGaaiikaiaadIhacqGHsislcaWGUbGaaiykaiabgUcaRiaad6gaa8  aabaWdbiaad6gaaaaacaGLOaGaayzkaaaaaa@5E51@  </annotation> </semantics></math><p>令${b_k} = \dfrac{( - 1)^k}{1 + k},{a_n} = \left( {\begin{array}{*{20}{c}}{B_n(x - n) + n}\\n\end{array}} \right)$</p><p>我们在反演公式2中进行变换</p><p>有</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mo>&#x2212;</mo><mi>x</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mrow><mo>(</mo>    <mrow>     <mtable>      <mtr>       <mtd>        <mrow>         <msub>          <mi>B</mi>          <mi>k</mi>         </msub>         <mo stretchy="false">(</mo><mi>x</mi><mo>&#x2212;</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi></mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mi>k</mi>       </mtd>      </mtr>     </mtable></mrow>   <mo>)</mo></mrow><mo>=</mo><mfrac>    <mrow>     <msup>      <mrow>       <mo stretchy="false">(</mo><mo>&#x2212;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>      <mi>n</mi>     </msup>     </mrow>    <mrow>     <mn>1</mn><mo>+</mo><mi>n</mi></mrow>   </mfrac>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiabgkHiTiaadIhaa8aabaWdbiaad6  gacqGHsislcaWGRbaaaaGaayjkaiaawMcaaaWcpaqaa8qacaWGRbGa  eyypa0JaaGimaaWdaeaapeGaamOBaaqdcqGHris5aOWaaeWaa8aaba  qbaeqabiqaaaqaa8qacaWGcbWdamaaBaaaleaapeGaam4AaaWdaeqa  aOWdbiaacIcacaWG4bGaeyOeI0Iaam4AaiaacMcacqGHRaWkcaWGRb  aapaqaa8qacaWGRbaaaaGaayjkaiaawMcaaiabg2da9maalaaapaqa  a8qacaGGOaGaeyOeI0IaaGymaiaacMcapaWaaWbaaSqabeaapeGaam  OBaaaaaOWdaeaapeGaaGymaiabgUcaRiaad6gaaaaaaa@5F38@  </annotation> </semantics></math><h3 id="神奇变换3"><a href="#神奇变换3" class="headerlink" title="神奇变换3"></a>神奇变换3</h3><p>有恒等式</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mrow>      <mi>n</mi><mo>&#x2212;</mo><mn>1</mn></mrow>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>z</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msup>    <mi>x</mi>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi><mo>&#x2212;</mo><mn>1</mn></mrow>   </msup>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>1</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>z</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><msup>    <mrow>     <mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>    <mrow>     <mi>k</mi><mo>&#x2212;</mo><mn>1</mn></mrow>   </msup>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiaadQhaa8aabaWdbiaadUgaaaaaca  GLOaGaayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaapaqaa8qa  caWGUbGaeyOeI0IaaGymaaqdcqGHris5aOGaamiEa8aadaahaaWcbe  qaa8qacaWGUbGaeyOeI0Iaam4AaiabgkHiTiaaigdaaaGccqGH9aqp  daaeWbWdaeaapeWaaeWaa8aabaqbaeqabiqaaaqaa8qacaWG6bGaey  OeI0Iaam4AaaWdaeaapeGaamOBaiabgkHiTiaadUgaaaaacaGLOaGa  ayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIXaaapaqaa8qacaWGUb  aaniabggHiLdGccaGGOaGaamiEaiabgUcaRiaaigdacaGGPaWdamaa  CaaaleqabaWdbiaadUgacqGHsislcaaIXaaaaaaa@6668@  </annotation> </semantics></math><p>通过反演，得出：</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mo>&#x2212;</mo><mi>x</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>i</mi><mo>=</mo><mn>0</mn></mrow>     <mrow>      <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>x</mi><mo>&#x2212;</mo><mi>i</mi><mo>&#x2212;</mo><mn>1</mn></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi><mo>&#x2212;</mo><mi>i</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mo stretchy="false">(</mo><mi>z</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msup>    <mi>z</mi>    <mi>n</mi>   </msup>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiabgkHiTiaadIhaa8aabaWdbiaadU  gaaaaacaGLOaGaayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaa  paqaa8qacaWGUbaaniabggHiLdGcdaaeWbWdaeaapeWaaeWaa8aaba  qbaeqabiqaaaqaa8qacaWG4bGaeyOeI0IaamyAaiabgkHiTiaaigda  a8aabaWdbiaad6gacqGHsislcaWGRbGaeyOeI0IaamyAaaaaaiaawI  cacaGLPaaaaSWdaeaapeGaamyAaiabg2da9iaaicdaa8aabaWdbiaa  d6gacqGHsislcaWGRbaaniabggHiLdGccaGGOaGaamOEaiabgUcaRi  aaigdacaGGPaGaeyypa0JaamOEa8aadaahaaWcbeqaa8qacaWGUbaa  aaaa@6495@  </annotation> </semantics></math><h3 id="神奇变换4"><a href="#神奇变换4" class="headerlink" title="神奇变换4"></a>神奇变换4</h3><p>有恒等式</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mrow>      <mi>n</mi><mo>&#x2212;</mo><mn>1</mn></mrow>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mi>z</mi>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mfrac>    <mrow>     <msup>      <mi>x</mi>      <mrow>       <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>     </msup>     </mrow>    <mrow>     <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>   </mfrac>   <mo>=</mo><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>1</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>z</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mfrac>    <mrow>     <msup>      <mrow>       <mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>      <mi>k</mi>     </msup>     <mo>&#x2212;</mo><mn>1</mn></mrow>    <mi>k</mi>   </mfrac>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiaadQhaa8aabaWdbiaadUgaaaaaca  GLOaGaayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaapaqaa8qa  caWGUbGaeyOeI0IaaGymaaqdcqGHris5aOWaaSaaa8aabaWdbiaadI  hapaWaaWbaaSqabeaapeGaamOBaiabgkHiTiaadUgaaaaak8aabaWd  biaad6gacqGHsislcaWGRbaaaiabg2da9maaqahapaqaa8qadaqada  WdaeaafaqabeGabaaabaWdbiaadQhacqGHsislcaWGRbaapaqaa8qa  caWGUbGaeyOeI0Iaam4AaaaaaiaawIcacaGLPaaaaSWdaeaapeGaam  4Aaiabg2da9iaaigdaa8aabaWdbiaad6gaa0GaeyyeIuoakmaalaaa  paqaa8qacaGGOaGaamiEaiabgUcaRiaaigdacaGGPaWdamaaCaaale  qabaWdbiaadUgaaaGccqGHsislcaaIXaaapaqaa8qacaWGRbaaaaaa  @6926@  </annotation> </semantics></math><p>通过反演，得出</p><math display="block"> <semantics>  <mrow>   <mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi><mo>=</mo><mn>0</mn></mrow>     <mi>n</mi>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mo>&#x2212;</mo><mi>z</mi></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mi>k</mi>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mstyle displaystyle="true">    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>i</mi><mo>=</mo><mn>0</mn></mrow>     <mrow>      <mi>n</mi><mo>&#x2212;</mo><mi>k</mi></mrow>    </munderover>    <mrow>     <mrow><mo>(</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>z</mi><mo>&#x2212;</mo><mi>i</mi><mo>&#x2212;</mo><mn>1</mn></mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>n</mi><mo>&#x2212;</mo><mi>k</mi><mo>&#x2212;</mo><mi>i</mi></mrow>         </mtd>        </mtr>       </mtable></mrow>     <mo>)</mo></mrow></mrow>   </mstyle><mfrac>    <mrow>     <msup>      <mrow>       <mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow>      <mrow>       <mi>i</mi><mo>+</mo><mn>1</mn></mrow>     </msup>     <mo>&#x2212;</mo><mn>1</mn></mrow>    <mrow>     <mi>i</mi><mo>+</mo><mn>1</mn></mrow>   </mfrac>   <mo>=</mo><mfrac>    <mrow>     <msup>      <mi>x</mi>      <mrow>       <mi>n</mi><mo>+</mo><mn>1</mn></mrow>     </msup>     </mrow>    <mrow>     <mi>n</mi><mo>+</mo><mn>1</mn></mrow>   </mfrac>   </mrow>  <annotation encoding="MathType-MTEF">MathType@MTEF@5@5@+=  feaahiart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn  hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr  4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr  pepC0xbbL8F4rqqrFfpeea0xe9Lq=Jc9vqaqpepm0xbba9pwe9Q8fs  0=yqaqpepae9pg0FirpepeKkFr0xfr=xfr=xb9adbaqaaeGaciGaai  aabeqaamaabaabauaakeaaqaaaaaaaaaWdbmaaqahapaqaa8qadaqa  daWdaeaafaqabeGabaaabaWdbiabgkHiTiaadQhaa8aabaWdbiaadU  gaaaaacaGLOaGaayzkaaaal8aabaWdbiaadUgacqGH9aqpcaaIWaaa  paqaa8qacaWGUbaaniabggHiLdGcdaaeWbWdaeaapeWaaeWaa8aaba  qbaeqabiqaaaqaa8qacaWG6bGaeyOeI0IaamyAaiabgkHiTiaaigda  a8aabaWdbiaad6gacqGHsislcaWGRbGaeyOeI0IaamyAaaaaaiaawI  cacaGLPaaaaSWdaeaapeGaamyAaiabg2da9iaaicdaa8aabaWdbiaa  d6gacqGHsislcaWGRbaaniabggHiLdGcdaWcaaWdaeaapeGaaiikai  aadIhacqGHRaWkcaaIXaGaaiyka8aadaahaaWcbeqaa8qacaWGPbGa  ey4kaSIaaGymaaaakiabgkHiTiaaigdaa8aabaWdbiaadMgacqGHRa  WkcaaIXaaaaiabg2da9maalaaapaqaa8qacaWG4bWdamaaCaaaleqa  baWdbiaad6gacqGHRaWkcaaIXaaaaaGcpaqaa8qacaWGUbGaey4kaS  IaaGymaaaaaaa@707C@  </annotation> </semantics></math><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们全文讨论了许多关于二项式系数的问题。二项式系数的恒等式可能远不止这些，还需要我们去发掘。</p><p>我们可以看到在恒等式变换部分，许多式子最终的形式都是非常美妙简洁的。在OI中，可以帮助加速运算。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1], Wikipedia, <a href="https://zh.wikipedia.org/wiki/二项式定理" target="_blank" rel="noopener">二项式定理</a></p><p>[2], Wikipedia, <a href="https://en.wikipedia.org/wiki/Binomial_theorem" target="_blank" rel="noopener">Binomial theorem</a></p><p>[3], Miskcoo’s Space , <a href="http://blog.miskcoo.com/2015/12/inversion-magic-binomial-inversion" target="_blank" rel="noopener">反演魔术：反演原理及二项式反演</a></p><p>[4], creatorx ,<a href="https://blog.csdn.net/creatorx/article/details/78155385" target="_blank" rel="noopener">二项式反演公式</a></p><p>[5], Wolframmathworld, <a href="http://mathworld.wolfram.com/BinomialTheorem.html" target="_blank" rel="noopener">Binomial theorem</a></p><p>[6], Peoplesju, <a href="http://people.sju.edu/~pklingsb/genbinom.pdf" target="_blank" rel="noopener">The Generalized Binomial Theorem</a></p><p>[7], <em>Concrete Mathematics</em>, 二项式系数</p>]]></content>
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2018/08/18/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2018/08/18/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      <content type="html"><![CDATA[<h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>不要把莫比乌斯反演和莫比乌斯变换当成一回事</li></ul><p>莫比乌斯变换的范围要广的多，别一眼看上去：哇，傻逼分式线性函数嘛，so easy！然后后面你就不懂了</p><p>详细看维基百科：<a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation" target="_blank" rel="noopener">Möbius transformation</a></p><p>还有这一篇<del>深度好文</del> <a href="http://www.math.bas.bg/~rkovach/lectures/Moebius.pdf" target="_blank" rel="noopener">Moebius.pdf</a></p><p>言归正传，回到topic。今天主要从数学角度去研究。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果对数论函数$f(n)$和$g(n)$，有以下关系式:</p><p>${\displaystyle g(n)=\sum _{d\,\mid \,n}f(d)\quad {\text{对于每个整数}}n\geq 1} $</p><p>那么有</p><p>${\displaystyle f(n)=\sum _{d\,\mid \,n}\mu (d)g\left({\frac {n}{d}}\right)\quad {\text{对于每个整数}}n\geq 1}$</p><p>其中$\mu$是莫比乌斯函数。实际上，原函数$f(n)$通过使用反演公式给定唯一的$g(n)$。$f$和$g$被称为对方的$莫比乌斯变换$</p><p>如果f和g是从正整数到某个阿贝尔群的函数（被看作ℤ - 模块），则该公式也是正确的。</p><p>用Dirichlet卷积描述，第一个公式可以写成${\displaystyle g = f * {\mathit {1}}}$</p><p>其中星号表示Dirichlet卷积，$\mathit{1}$是常数函数$\mathit{1}(n)=1$。然后将第二个公式写成$f = \mu * g$</p><p>因为卷乘是(可交换的)和关联的，并且$\mathit{1} * \mu=\varepsilon$，而$\varepsilon$是Dirichlet卷积中的单位函数</p><p>所以我们有：</p><script type="math/tex; mode=display">\mu * g = \mu *({\mathit{1}} * f)=(\mu * {\mathit{1}}) * f = \varepsilon * f = f</script><p>仅仅是数论函数？我们来看看它的一般形式：</p><a id="more"></a><h2 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h2><p>设 ${\displaystyle F(x)}$及 ${\displaystyle G(x)}$ 为定义在$ {\displaystyle [1,\infty )}$上的复值函数并且有${\displaystyle G(x)=\sum _{1\leqslant n\leqslant x}F\left({\frac {x}{n}}\right)} $</p><p>那么有${\displaystyle F(x)=\sum _{1\leqslant n\leqslant x}\mu (n)G\left({\frac {x}{n}}\right)} $</p><h2 id="级数关系"><a href="#级数关系" class="headerlink" title="级数关系"></a>级数关系</h2><p>令${\displaystyle a_{n}=\sum _{d\mid n}b_{d}} $</p><p>那么${\displaystyle b_{n}=\sum _{d\mid n}\mu \left({\frac {n}{d}}\right)a_{d}} $</p><p>就是它的莫比乌斯变换。</p><ul><li>与<strong>Lambert 级数</strong>的意义相关：</li></ul><p>${\displaystyle \sum _{n=1}^{\infty }a_{n}x^{n}=\sum _{n=1}^{\infty }b_{n}{\frac {x^{n}}{1-x^{n}}}} $</p><ul><li>还有<strong>Dirichlet级数</strong>：</li></ul><p>${\displaystyle \sum _{n=1}^{\infty }{\frac {a_{n}}{n^{s}}}=\zeta (s)\sum _{n=1}^{\infty }{\frac {b_{n}}{n^{s}}}} $，其中$\zeta(s)$是黎曼$\zeta$函数</p><ul><li>与<strong>分圆多项式</strong>的<strong>对数</strong>相关</li></ul><p>$\Phi_n(x)=\prod_\limits{d|n}(1-x^{\frac{n}{d}})^{\mu(d)}$</p><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>在组合学中更有用的相关反演公式如下：</p><p>假设$F(x)$和$G(x)$都是定义在区间$[1,\infty)$上的复值函数，使得</p><p>${\displaystyle G(x)=\sum _{1\leq n\leq x}F\left({\frac {x}{n}}\right)\quad {\mbox{ 对于所有}}x\geq 1} $</p><p>于是就有</p><p>${\displaystyle F(x)=\sum _{1\leq n\leq x}\mu (n)G\left({\frac {x}{n}}\right)\quad {\mbox{ 对于所有}}x\geq 1.} $</p><p>这里，总和扩展到小于或等于x的所有正整数n。 </p><p>反过来，我们得到了更为特殊的基本形式：</p><p>如果$\alpha(n)$是一个算术函数，并且具有Dirichlet逆$\alpha^{-1}(n)$</p><p>定义${\displaystyle G(x)=\sum _{1\leq n\leq x}\alpha (n)F\left({\frac {x}{n}}\right)\quad {\mbox{ 对于所有 }}x\geq 1} $</p><p>那么有${\displaystyle F(x)=\sum _{1\leq n\leq x}\alpha ^{-1}(n)G\left({\frac {x}{n}}\right)\quad {\mbox{对于所有 }}x\geq 1.} $</p><p>前面的公式若出现在常数函数$\alpha(n)=1$的特殊情况下，它的Dirichlet逆就是$\mu(n)$</p><p>如果我们在正整数上定义了复值函数$f(n)$和$g(n)$，则会出现第一个扩展的特定应用：</p><p>${\displaystyle g(n)=\sum _{1\leq m\leq n}f\left(\left\lfloor {\frac {n}{m}}\right\rfloor \right)\quad {\mbox{ 对于所有 }}n\geq 1.} $ </p><p>定义$F(x)=f(\lfloor x\rfloor)$和$G(x)=g(\lfloor x\rfloor)$</p><p>我们得到${\displaystyle f(n)=\sum _{1\leq m\leq n}\mu (m)g\left(\left\lfloor {\frac {n}{m}}\right\rfloor \right)\quad {\mbox{ 对于所有 }}n\geq 1.} $</p><p>另外一个反转公式则是</p><p>${\displaystyle g(x)=\sum _{m=1}^{\infty }{\frac {f(mx)}{m^{s}}}\quad {\mbox{ for all }}x\geq 1\quad \Longleftrightarrow \quad f(x)=\sum _{m=1}^{\infty }\mu (m){\frac {g(mx)}{m^{s}}}\quad {\mbox{ 对于所有 }}x\geq 1.} $</p><p>和前面类似，推广到$\alpha(n)$是一个算术函数，并且具有Dirichlet逆$\alpha^{-1}(n)$的情况：</p><p>${\displaystyle g(x)=\sum _{m=1}^{\infty }\alpha (m){\frac {f(mx)}{m^{s}}}\quad {\mbox{ for all }}x\geq 1\quad \Longleftrightarrow \quad f(x)=\sum _{m=1}^{\infty }\alpha ^{-1}(m){\frac {g(mx)}{m^{s}}}\quad {\mbox{ 对于所有 }}x\geq 1.} $</p><h2 id="在偏序集上的反演"><a href="#在偏序集上的反演" class="headerlink" title="在偏序集上的反演"></a>在偏序集上的反演</h2><p>对于一个偏序集$P$(每个<strong>主序理想</strong>有限)，用${\displaystyle \mu (s,s)=1{\text{ for }}s\in P,\qquad \mu (s,u)=-\sum _{s\leq t&lt;u}\mu (s,t),\quad {\text{ for }}s&lt;u{\text{ in }}P.} $递归地定义莫比乌斯函数$\mu$</p><p>对于$ {\displaystyle f,g:P\to K}$($K$为域) ，有${\displaystyle g(t)=\sum _{s\leq t}f(s)\qquad {\text{ for all }}t\in P} $当且仅当${\displaystyle f(t)=\sum _{s\leq t}g(s)\mu (s,t)\qquad {\text{ for all }}t\in P.} $</p><h2 id="加法换成乘法？"><a href="#加法换成乘法？" class="headerlink" title="加法换成乘法？"></a>加法换成乘法？</h2><ul><li>由于莫比乌斯反演适用于<strong>任何阿贝尔群</strong>，因此群作用是加法还是乘法没有区别。这产生了以下反演公式的符号变形：</li><li>${\displaystyle {\mbox{若}}F(n)=\prod _{d|n}f(d),{\mbox{ 则 }}f(n)=\prod _{d|n}F\left({\frac {n}{d}}\right)^{\mu (d)}.} $</li></ul><h2 id="简要证明"><a href="#简要证明" class="headerlink" title="简要证明"></a>简要证明</h2><p>拿第一次推广为例：</p><p>${\displaystyle {\begin{aligned}\sum _{1\leq n\leq x}\mu (n)g\left({\frac {x}{n}}\right)&amp;=\sum _{1\leq n\leq x}\mu (n)\sum _{1\leq m\leq {\frac {x}{n}}}f\left({\frac {x}{mn}}\right)\\&amp;=\sum _{1\leq n\leq x}\mu (n)\sum _{1\leq m\leq {\frac {x}{n}}}\sum _{1\leq r\leq x}[r=mn]f\left({\frac {x}{r}}\right)\\&amp;=\sum _{1\leq r\leq x}f\left({\frac {x}{r}}\right)\sum _{1\leq n\leq x}\mu (n)\sum _{1\leq m\leq {\frac {x}{n}}}\left[m={\frac {r}{n}}\right]\qquad {\text{重新排列和式的顺序}}\\&amp;=\sum _{1\leq r\leq x}f\left({\frac {x}{r}}\right)\sum _{n|r}\mu (n)\\&amp;=\sum _{1\leq r\leq x}f\left({\frac {x}{r}}\right)i(r)\\&amp;=f(x)\qquad {\text{当}}i(r)=0{\text{ ,除了 }}r=1{\text{ 的情况 }}\end{aligned}}} $</p><p>$\alpha(n)$替换$\mathit{1}$的更一般情况下的证明基本相同，第二次推广也是如此。 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Wikipedia, <a href="https://en.wikipedia.org/wiki/M%C3%B6bius_inversion_formula" target="_blank" rel="noopener">Möbius inversion formula</a></p><p>[2] wolfram mathworld, <a href="http://mathworld.wolfram.com/MoebiusInversionFormula.html" target="_blank" rel="noopener">Möbius Inversion Formula</a></p><p>[3] Mobius Inversion Formula, Zeta Functions, Lecture 14 Notes <a href="https://ocw.mit.edu/courses/mathematics/18-781-theory-of-numbers-spring-2012/lecture-notes/MIT18_781S12_lec14.pdf" target="_blank" rel="noopener">Here</a></p><p>[4] Twisted One 151’s Weblog, <a href="https://twistedone151.wordpress.com/tag/mobius-inversion-formula/" target="_blank" rel="noopener">Möbius Inversion Formula</a></p>]]></content>
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>疯狂的馒头---并查集的妙用</title>
      <link href="/2018/05/16/%E7%96%AF%E7%8B%82%E7%9A%84%E9%A6%92%E5%A4%B4%5B%E5%B9%B6%E6%9F%A5%E9%9B%86%5D/"/>
      <url>/2018/05/16/%E7%96%AF%E7%8B%82%E7%9A%84%E9%A6%92%E5%A4%B4%5B%E5%B9%B6%E6%9F%A5%E9%9B%86%5D/</url>
      <content type="html"><![CDATA[<h1 id="疯狂的馒头"><a href="#疯狂的馒头" class="headerlink" title="疯狂的馒头"></a>疯狂的馒头</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p><strong>Description</strong></p><p>CQF十分喜欢吃馒头，兴奋之下他一下子买了N 个馒头请所有认识他的人吃。</p><p>但是CQF不喜欢白色，喜欢红色、黄色、绿色等鲜艳的颜色。于是他把所有白色的馒头排成一列。然后进行M 次染色操作。每个染色操作都是用一个神奇的刷子把连续的多个馒头染成特定的某种颜色。一个馒头最终的颜色是最后一次染它的颜色。如果一个馒头没有被染过色，那么它的颜色就是白色。</p><p>现在CQF已经定好了染色计划：在第i次染色操作中，把第$(i × p + q)\ mod\ N + 1$个馒头和第$(i × q + p)\ mod\ N+1$个馒头之间的馒头染成颜色i，其中p, q是特定的两个正整数。他想立即知道最后每个馒头的颜色。你能帮他吗？</p><a id="more"></a><p><strong>输入格式</strong><br>第一行四个正整数N ，M ，p，q。<br><strong>输出格式</strong><br>一共输出N 行，第i行表示第i个馒头的最终颜色（如果最终颜色是白色就输出0）。<br><strong>输入样例</strong></p><p><textarea rows="1" cols="10"><br>4 3 2 4</textarea><br><strong>输出样例</strong></p><p><textarea rows="4" cols="10"><br>2<br>2<br>3<br>0 </textarea><br><strong>数据规模</strong><br>$1 ≤ N ≤ 1000000，1 ≤ M ≤ 10000000$</p><p>保证所以输入数据中$1 ≤ M∗p+q，M∗q+p ≤ 2^{31}-1$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><a href="\images\fm.pdf">题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此题需要调整系统栈大小（编译器命令中） </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MA (i * p + q) % N + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB (i * q + p) % N + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000 + 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, p, q;</span><br><span class="line"><span class="keyword">int</span> x[MAXN], f[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ffa</span><span class="params">(<span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x[r] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ffa(f[r]);</span><br><span class="line">        r = f[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        t = -t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">9</span>)</span><br><span class="line">        print(t / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(t % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **Argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"bread.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"bread.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span> x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        f[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == M - N) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> j = min(MA, MB);</span><br><span class="line">        <span class="keyword">int</span> k = max(MA, MB);</span><br><span class="line">        ffa(j);</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= k)</span><br><span class="line">            x[j] = i, ffa(j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">    print(x[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1000000 10000000 16 188</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>天鹅会面 [BFS+SPFA]</title>
      <link href="/2018/05/16/%E5%A4%A9%E9%B9%85%E4%BC%9A%E9%9D%A2%20%5BBFS+SPFA%5D/"/>
      <url>/2018/05/16/%E5%A4%A9%E9%B9%85%E4%BC%9A%E9%9D%A2%20%5BBFS+SPFA%5D/</url>
      <content type="html"><![CDATA[<h1 id="天鹅会面-BFS-SPFA"><a href="#天鹅会面-BFS-SPFA" class="headerlink" title="天鹅会面 [BFS+SPFA]"></a>天鹅会面 [BFS+SPFA]</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>两头白天鹅生活在一个部分湖面结了冰的湖泊中，湖面的形状为一个长方形，并且被分割成R行C列的小方格，某些方格中结了冰，这样的方格称之为冰格，其余的方格称之为水格。</p><p>冬天过去了，湖面上的冰渐渐开始溶解了，每一天与水相邻的冰格就将消融而转化为水格。所谓两个方格相邻是指它们在水平或垂直方向有公共边，两个呈对角的方格是不相邻的。</p><p>白天鹅只能在水中沿水平或垂直方向游动，写一个程序判断多少天后两只白天鹅才能够相会。</p><a id="more"></a><p><strong>输入</strong></p><p>输入文件第一行包含两个用空格隔开的整数R 和C，其中1≤R,C≤1500，接下来的R行每行包含C个字符，描述湖面的初始状态，‘·’表示水格，‘X’表示冰格，‘L’表示一只白天鹅。</p><p><strong>输出</strong></p><p>输出文件仅一行包含一个整数表示两只白天鹅等到相邻那一天所需的天数。</p><p><strong>样例</strong></p><p>_SWAN.IN_</p><p>8 17</p><p>…XXXXXX..XX.XXX</p><p>….XXXXXXXXX.XXX</p><p>…XXXXXXXXXXXX..</p><p>..XXXXX.LXXXXXX..</p><p>.XXXXXX..XXXXXX..</p><p>XXXXXXX…XXXX…</p><p>..XXXXX…XXX….</p><p>….XXXXX.XXXL…</p><p>_SWAN.OUT_</p><p>2</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题一个很简单的想法就是，先用BFS求出每个点消融的时间。对于本来就是水域的点，消融时间为0。注意到天鹅只能按照横轴或者纵轴移动，并且瞬间移动无限远，因此只要判定两只天鹅的最短时间即可。考虑SPFA的模型，我们只需将松弛距离的操作改为松弛时间的操作即可，在融冰的时间与当前最短时间中取max即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1500 + 5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> R, C;</span><br><span class="line"><span class="keyword">char</span> Map[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> melt[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">node(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line"><span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; Q1;</span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; Q2;</span><br><span class="line">node loc[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> t;</span><br><span class="line"><span class="keyword">for</span> (t = getchar();t != <span class="string">'.'</span> &amp;&amp; t != <span class="string">'X'</span> &amp;&amp; t != <span class="string">'L'</span>; t = getchar());</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis); </span><br><span class="line"><span class="keyword">while</span> (Q1.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = Q1.front().x, y = Q1.front().y;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span> &amp;&amp; !vis[x - <span class="number">1</span>][y] &amp;&amp; melt[x][y] + <span class="number">1</span> &lt; melt[x - <span class="number">1</span>][y])</span><br><span class="line">&#123;</span><br><span class="line">melt[x - <span class="number">1</span>][y] = melt[x][y] + <span class="number">1</span>;</span><br><span class="line">vis[x - <span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">Q1.push(node(x - <span class="number">1</span>, y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x &lt; R &amp;&amp; !vis[x + <span class="number">1</span>][y] &amp;&amp; melt[x][y] + <span class="number">1</span> &lt; melt[x + <span class="number">1</span>][y])</span><br><span class="line">&#123;</span><br><span class="line">melt[x + <span class="number">1</span>][y] = melt[x][y] + <span class="number">1</span>;</span><br><span class="line">vis[x + <span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">Q1.push(node(x + <span class="number">1</span>, y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y &gt; <span class="number">1</span> &amp;&amp; !vis[x][y - <span class="number">1</span>] &amp;&amp; melt[x][y] + <span class="number">1</span> &lt; melt[x][y - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">melt[x][y - <span class="number">1</span>] = melt[x][y] + <span class="number">1</span>;</span><br><span class="line">vis[x][y - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">Q1.push(node(x, y - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y &lt; C &amp;&amp; !vis[x][y + <span class="number">1</span>] &amp;&amp; melt[x][y] + <span class="number">1</span> &lt; melt[x][y + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">melt[x][y + <span class="number">1</span>] = melt[x][y] + <span class="number">1</span>;</span><br><span class="line">vis[x][y + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">Q1.push(node(x, y + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">Q1.pop(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">dis[x][y] = <span class="number">0</span>;</span><br><span class="line">Q2.push(node(x, y));</span><br><span class="line">vis[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (Q2.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = Q2.front().x, b = Q2.front().y;</span><br><span class="line">Q2.pop();</span><br><span class="line">vis[a][b] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span> &amp;&amp; dis[a][b] &lt; dis[a - <span class="number">1</span>][b] &amp;&amp; dis[a - <span class="number">1</span>][b] != melt[a - <span class="number">1</span>][b])</span><br><span class="line">&#123;</span><br><span class="line">dis[a - <span class="number">1</span>][b] = max(dis[a][b], melt[a - <span class="number">1</span>][b]);</span><br><span class="line"><span class="keyword">if</span> (!vis[a - <span class="number">1</span>][b])</span><br><span class="line">Q2.push(node(a - <span class="number">1</span>, b)), vis[a - <span class="number">1</span>][b] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a &lt; R &amp;&amp; dis[a][b] &lt; dis[a + <span class="number">1</span>][b] &amp;&amp; dis[a + <span class="number">1</span>][b] != melt[a + <span class="number">1</span>][b])</span><br><span class="line">&#123;</span><br><span class="line">dis[a + <span class="number">1</span>][b] = max(dis[a][b], melt[a + <span class="number">1</span>][b]);</span><br><span class="line"><span class="keyword">if</span> (!vis[a + <span class="number">1</span>][b])</span><br><span class="line">Q2.push(node(a + <span class="number">1</span>, b)), vis[a + <span class="number">1</span>][b] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b &gt; <span class="number">1</span> &amp;&amp; dis[a][b] &lt; dis[a][b - <span class="number">1</span>] &amp;&amp; dis[a][b - <span class="number">1</span>] != melt[a][b - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dis[a][b - <span class="number">1</span>] = max(dis[a][b], melt[a][b - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!vis[a][b - <span class="number">1</span>])</span><br><span class="line">Q2.push(node(a, b - <span class="number">1</span>)), vis[a][b - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b &lt; C &amp;&amp; dis[a][b] &lt; dis[a][b + <span class="number">1</span>] &amp;&amp; dis[a][b + <span class="number">1</span>] != melt[a][b + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dis[a][b + <span class="number">1</span>] = max(dis[a][b], melt[a][b + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!vis[a][b + <span class="number">1</span>])</span><br><span class="line">Q2.push(node(a, b + <span class="number">1</span>)), vis[a][b + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **Argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"swan.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"swan.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; R &gt;&gt; C;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3F</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="built_in">memset</span>(melt, <span class="number">0x3F</span>, <span class="keyword">sizeof</span> melt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= C; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> p = getch();</span><br><span class="line"><span class="keyword">if</span> (p == <span class="string">'.'</span>)</span><br><span class="line">&#123;</span><br><span class="line">Q1.push(node(i, j));</span><br><span class="line">vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">melt[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="string">'L'</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">melt[i][j] = <span class="number">0</span>;</span><br><span class="line">loc[++tot].x = i;</span><br><span class="line">loc[tot].y = j;</span><br><span class="line">Q1.push(node(i, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS();</span><br><span class="line">SPFA(loc[<span class="number">1</span>].x, loc[<span class="number">1</span>].y);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[loc[<span class="number">2</span>].x][loc[<span class="number">2</span>].y] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『POJ 2229 』 Sumsets</title>
      <link href="/2018/05/15/%E3%80%8EPOJ%202229%E3%80%8F%20Sumsets/"/>
      <url>/2018/05/15/%E3%80%8EPOJ%202229%E3%80%8F%20Sumsets/</url>
      <content type="html"><![CDATA[<h1 id="『POJ-2229』-Sumsets"><a href="#『POJ-2229』-Sumsets" class="headerlink" title="『POJ 2229』 Sumsets"></a>『POJ 2229』 Sumsets</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p><a href="http://poj.org/problem?id=2229" target="_blank" rel="noopener">传送门</a></p><p><strong>Description</strong></p><p>Farmer John commanded his cows to search for different sets of numbers that sum to a given number. The cows use only numbers that are an integer power of 2. Here are the possible sets of numbers that sum to 7: </p><p> 1) 1+1+1+1+1+1+1 </p><p>2) 1+1+1+1+1+2 </p><p>3) 1+1+1+2+2  </p><p>4) 1+1+1+4  </p><p>5) 1+2+2+2 </p><p>6) 1+2+4 </p><p> Help FJ count all possible representations for a given integer N (1 &lt;= N &lt;= 1,000,000).  </p><a id="more"></a><p><strong>Input</strong></p><p>A single line with a single integer, N. </p><p><strong>Output</strong></p><p>The number of ways to represent N as the indicated sum. Due to the potential huge size of this number, print only last 9 digits (in base 10 representation). </p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>DP 水题</p><p>记<code>f[i]</code>为考虑的数字为i时的方案数</p><p>易得当i为奇数时，与i-1方案数相同。i为偶数时，<code>f[i] = f[i - 1] + f[i &gt;&gt; 1]</code>。</p><p>根据此转移方程，易得代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000 + 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **Argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f[i] = (f[i - <span class="number">1</span>] + f[i &gt;&gt; <span class="number">1</span>]) % <span class="number">1000000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>『POJ 2376 』 Cleaning Shifts</title>
      <link href="/2018/05/15/%E3%80%8EPOJ%202376%E3%80%8F%20Cleaning%20Shifts/"/>
      <url>/2018/05/15/%E3%80%8EPOJ%202376%E3%80%8F%20Cleaning%20Shifts/</url>
      <content type="html"><![CDATA[<h1 id="『POJ-2376-』-Cleaning-Shifts"><a href="#『POJ-2376-』-Cleaning-Shifts" class="headerlink" title="『POJ 2376 』 Cleaning Shifts"></a>『POJ 2376 』 Cleaning Shifts</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p><strong>Description</strong></p><p>Farmer John is assigning some of his N (1 &lt;= N &lt;= 25,000) cows to do some cleaning chores around the barn. He always wants to have one cow working on cleaning things up and has divided the day into T shifts (1 &lt;= T &lt;= 1,000,000), the first being shift 1 and the last being shift T.<br>Each cow is only available at some interval of times during the day for work on cleaning. Any cow that is selected for cleaning duty will work for the entirety of her interval.<br>Your job is to help Farmer John assign some cows to shifts so that (i) every shift has at least one cow assigned to it, and (ii) as few cows as possible are involved in cleaning. If it is not possible to assign a cow to each shift, print -1.</p><a id="more"></a><p><strong>Input</strong></p><p>* Line 1: Two space-separated integers: N and T<br>* Lines 2..N+1: Each line contains the start and end times of the interval during which a cow can work. A cow starts work at the start time and finishes after the end time.</p><p><strong>Output</strong></p><p>* Line 1: The minimum number of cows Farmer John needs to hire or -1 if it is not possible to assign a cow to each shift.</p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 10</span><br><span class="line">1 7</span><br><span class="line">3 6</span><br><span class="line">6 10</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>This problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.<br>INPUT DETAILS:<br>There are 3 cows and 10 shifts. Cow #1 can work shifts 1..7, cow #2 can work shifts 3..6, and cow #3 can work shifts 6..10.<br>OUTPUT DETAILS:<br>By selecting cows #1 and #3, all shifts are covered. There is no way to cover all the shifts using fewer than 2 cows.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>人话题目大意：</p><p>给你若干个小区间和一个大区间，需要你用最少的小区间个数以覆盖整个大区间</p><p>可以说数据还是可以的，被卡了好多次。。。</p><p>贪心即可</p><p>按每头奶牛工作的开始时间排序，然后每次在合法的牛之间选工作结束最晚的，这样就能保证答案最小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 25000 + 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> s, e;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.s &lt; b.s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(s)) &#123; <span class="keyword">if</span> (s == <span class="string">'-'</span>) f = <span class="number">-1</span>; s = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(s)) &#123; x = x * <span class="number">10</span> + s - <span class="string">'0'</span>; s = getchar(); &#125;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **Argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">read(N), read(T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">read(a[i].s), read(a[i].e);</span><br><span class="line">sort(a + <span class="number">1</span>, a + N + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ed = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ti = i, edmax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a[i + <span class="number">1</span>].s &lt;= ed + <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= N) edmax = max(edmax, a[++i].e);<span class="comment">//保证不越界，并且在能选择的范围内选择最优的答案 </span></span><br><span class="line"><span class="keyword">if</span> (ti == i &amp;&amp; i &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ed = edmax, tot++;</span><br><span class="line"><span class="keyword">if</span> (ed &gt;= T)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POJ </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Codeforces 825B」Five-In-a-Row</title>
      <link href="/2018/05/06/%E3%80%8CCodeforces%20825B%E3%80%8DFive-In-a-Row/"/>
      <url>/2018/05/06/%E3%80%8CCodeforces%20825B%E3%80%8DFive-In-a-Row/</url>
      <content type="html"><![CDATA[<p>题目链接: <a href="http://codeforces.com/contest/825/problem/B" target="_blank" rel="noopener">点我</a></p><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>B. Five-In-a-Row<br>time limit per test :1 second<br>memory limit per test :256 megabytes<br><strong>Description</strong><br>Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts.</p><p>In current match they have made some turns and now it’s Alice’s turn. She wonders if she can put cross in such empty cell that she wins immediately.</p><p>Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.</p><a id="more"></a><p><strong>Input</strong><br>You are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters ‘X’ being a cross, letters ‘O’ being a nought and ‘.’ being an empty cell. The number of ‘X’ cells is equal to the number of ‘O’ cells and there is at least one of each type. There is at least one empty cell.</p><p>It is guaranteed that in the current arrangement nobody has still won.</p><p><strong>Output</strong><br>Print <code>YES</code> if it’s possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print <code>NO</code>.</p><p><strong>Examples</strong><br>input1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.....OOOO.</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br></pre></td></tr></table></figure></p><p>output1<br><code>YES</code></p><p>input2<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OO.O......</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br></pre></td></tr></table></figure></p><p>output2<br><code>NO</code></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>直接模拟，不多解释，你懂的</p><p>AC 31ms<br>​<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chk <span class="meta-keyword">if</span> (num &gt;= 5) return true;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> M[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> t = getchar();</span><br><span class="line"><span class="keyword">while</span> (t != <span class="string">'.'</span> &amp;&amp; t != <span class="string">'O'</span> &amp;&amp; t != <span class="string">'X'</span>) t = getchar();</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">checkwin</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> xx = x, yy = y;</span><br><span class="line"><span class="comment">//horizontal</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (M[xx][y] == <span class="string">'X'</span>) xx--, num++;</span><br><span class="line">xx = x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (M[xx][y] == <span class="string">'X'</span>) xx++, num++;</span><br><span class="line">chk</span><br><span class="line"></span><br><span class="line"><span class="comment">//vertical</span></span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (M[x][yy] == <span class="string">'X'</span>) yy--, num++;</span><br><span class="line">yy = y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (M[x][yy] == <span class="string">'X'</span>) yy++, num++;</span><br><span class="line">chk</span><br><span class="line"></span><br><span class="line">xx = x, yy = y, num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//case 1</span></span><br><span class="line"><span class="keyword">while</span> (M[xx][yy] == <span class="string">'X'</span>) xx--, yy--, num++;</span><br><span class="line">xx = x + <span class="number">1</span>, yy = y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (M[xx][yy] == <span class="string">'X'</span>) xx++, yy++, num++;</span><br><span class="line">chk</span><br><span class="line"><span class="comment">//case 2</span></span><br><span class="line">xx = x, yy = y, num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (M[xx][yy] == <span class="string">'X'</span>) xx++, yy--, num++;</span><br><span class="line">xx = x - <span class="number">1</span>, yy = y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (M[xx][yy] == <span class="string">'X'</span>) xx--, yy++, num++;</span><br><span class="line">chk</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">M[i][j] = getch();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][j] == <span class="string">'.'</span>)</span><br><span class="line">&#123;</span><br><span class="line">M[i][j] = <span class="string">'X'</span>;</span><br><span class="line"><span class="keyword">if</span> (checkwin(i, j))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">M[i][j] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 水题 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSTSC 2018滚粗记</title>
      <link href="/2018/05/04/JSTSC%202018%E6%BB%9A%E7%B2%97%E8%AE%B0/"/>
      <url>/2018/05/04/JSTSC%202018%E6%BB%9A%E7%B2%97%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="JSTSC-2018滚粗记"><a href="#JSTSC-2018滚粗记" class="headerlink" title="JSTSC 2018滚粗记"></a>JSTSC 2018滚粗记</h1><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>第一眼：what???一上来就图论???<br>后来看看：嗯…好像这个数据范围…<br>10分肯定是到手了…<br>（突然看到一条链的情况）<br>这个条件很诱人耶要不要来做着试试？<br>话说这题应该是个dp事实上它也就是个dp然后开始推一条链的方程<br>结果:<br>???????</p><p>什么鬼…<br>算了算了，这道题已经磕了2个小时了还是看看下一题吧..</p><a id="more"></a><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>Steiner Tree?????<br>直接弃坑</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>这道题看起来很可做的样子…<br>（首先看到了20分）<br>噫！那么我们可以暴力枚举浮点数（这方法真是太蠢辣）然后构造等边三角形依次判咯？<br>好方法<br>那么我们知道一个点和一个圆怎么知道另外两个点的坐标呢？<br>也就是说要解个方程…啦<br>也就是说我们在我们枚举出来的那个点上（那个店在半径为$R$的圆上）<br>作一个半径为$\sqrt{3}R$的圆，交原来的圆与两点<br>所以那两点就是三角形的另外两个点<br>设我们枚举的点为$(a, b)$<br>解方程如下，我考场上实在是推不下去了回家拿Mathematica推了一下….<br><img src="\images\wewew.png" alt=""></p><p>化简过后<br><img src="\images\wewew1.png" alt=""><br>结果最后还因为精度问题挂了（颓废）</p><p>总体体验：差评</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h3><p>计算几何吧…<br>毒瘤题<br>不会，再见<br>（最后瞎jb乱写了一个居然骗到10分）</p><h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p>计数DP？？？<br>我想错了<br>反正不会，再见</p><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>暴力贼jb好写…（噼里啪啦）<br>等等..要不写个贪心玩玩？<br>开始作死(flag)<br>好啦·~似乎能拿很多分诶<br>拍的数据都过啦~<br>然后<br>…<br>…<br>…<br>这题爆零啦~<br><img src="\images\buzhisuocuo.jpg" alt=""><br>简直智障，我就不应该作死交贪心的<br>艹</p><p>两天总评：状态较好，顺利滚粗。</p>]]></content>
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单调栈</title>
      <link href="/2018/05/01/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2018/05/01/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      <content type="html"><![CDATA[<ul><li>题外话<br>2333感觉uups里面真的是愈发有趣、有趣得一塌糊涂不可收拾<br><a href="https://jq.qq.com/?_wv=1027&amp;k=55zJj9R" target="_blank" rel="noopener">点击加入群聊【科技区UP主抱团交流群】</a><br>欢迎入坑参与身♂心♂愉悦的聊天</li></ul><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>单调递增或单调减的栈，只用到它的一端，利用它可以用来解决一些ACM/ICPC和OI的题目，如RQNOJ 的诺诺的队列等。</p></blockquote><p>假设如下是一个栈内元素的排列情况(单调递增的栈)：<br>$1 \rightarrow 2 \rightarrow 4 \rightarrow6$<br>此时插入情况有两种：<br>(1)插入元素大于栈顶元素<br>当插入$7$时，因$7 &gt; 6$，满足单调递增的条件，故可以直接加入栈<br>此时：<br>$1\rightarrow 2 \rightarrow 4 \rightarrow 6 \rightarrow 7$<br>(2)插入的元素小于栈顶元素<br>当插入$3$时，为了满足单调递增栈的性质，需要先将栈顶的$4,6$弹出，再插入<br>此时<br>$1\rightarrow 2\rightarrow 4$<br>$1 \rightarrow 2$<br>$1 \rightarrow 2\rightarrow 3$</p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>一言以蔽之<br><strong>一个元素向左遍历的第一个比它小的数的位置就是将它插入单调栈时栈顶元素的值，若栈为空，则说明不存在这么一个数。然后将此元素的下标存入栈，就能类似迭代般地求解后面的元素</strong></p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>【问题描述】</p><p>一个数列有N个整数，记为A1…An。<br>对于第i个数Ai，定义它的控制范围为由数列中不超过Ai的整数组成并且包含Ai的极大的区间[Li, Ri]。<br>对每个数求出它的控制范围。</p><p>【输入格式】</p><p>输入文件的第一行包括一个正整数N,表示有N个数。<br>第二行有N个整数，之间用空格隔开。</p><p>【输出格式】</p><p>输出文件包括N行，每行2个整数，依次表示每个整数的控制范围。</p><p>【样例输入】<br>3<br>5 4 7<br>【样例输出】<br>1 2<br>2 2<br>1 3</p><p>【数据规模与约定】<br>20%的数据满足，1 &lt;= N &lt;= 1 000.<br>100%的数据满足，1 &lt;= N &lt;= 100 000，0 &lt;= Ai &lt;= 109.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>不多解释，你懂的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000 + 10</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN], s[MAXN], t, l[MAXN], r[MAXN], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">freopen(<span class="string">"a.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"a.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = INT_MAX;</span><br><span class="line">s[<span class="number">1</span>] = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (a[s[t]] &lt;= a[i]) --t;</span><br><span class="line">l[i] = s[t] + <span class="number">1</span>; s[++t] = i;</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">1</span>] = n + <span class="number">1</span>, t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (a[s[t]] &lt;= a[i]) --t;</span><br><span class="line">r[i] = s[t] - <span class="number">1</span>; s[++t] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ 1935」「洛谷 P2163」「CodeVS 2342」[SHOI2007]Tree 园丁的烦恼</title>
      <link href="/2018/04/15/%E3%80%8CBZOJ%201935%E3%80%8D%E3%80%8C%E6%B4%9B%E8%B0%B7%20P2163%E3%80%8D%E3%80%8CCodeVS%202342%E3%80%8D%5BSHOI2007%5DTree%20%E5%9B%AD%E4%B8%81%E7%9A%84%E7%83%A6%E6%81%BC/"/>
      <url>/2018/04/15/%E3%80%8CBZOJ%201935%E3%80%8D%E3%80%8C%E6%B4%9B%E8%B0%B7%20P2163%E3%80%8D%E3%80%8CCodeVS%202342%E3%80%8D%5BSHOI2007%5DTree%20%E5%9B%AD%E4%B8%81%E7%9A%84%E7%83%A6%E6%81%BC/</url>
      <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>题目描述 Description</strong><br>很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。有一天国王漫步在花园里，若有所思，他问一个园丁道：<br>“最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……”<br>“那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。<br>“嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……”<br>“是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。<br>“该死的，你究竟是什么来头？”<br>“陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！”<br>王者的尊严受到了伤害，这是不可容忍的。看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力：</p><p>“年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。</p><p>这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。</p><p><strong>输入描述 Input Description</strong><br>文件的第一行有两个整数n，m（0≤n≤500000，1≤m≤500000）。n代表皇家花园的树木的总数，m代表骑士们询问的次数。<br>文件接下来的n行，每行都有两个整数xi，yi，代表第i棵树的坐标（0≤xi，yi≤10000000）。<br>文件的最后m行，每行都有四个整数aj，bj，cj，dj，表示第j次询问，其中所问的矩形以（aj，bj）为左下坐标，以（cj，dj）为右上坐标。</p><p><strong>输出描述 Output Description</strong><br>共输出m行，每行一个整数，即回答国王以（aj，bj）和（cj，dj）为界的矩形里有多少棵树。</p><p><strong>样例输入 Sample Input</strong><br>3 1<br>0 0<br>0 1<br>1 0<br>0 0 1 1</p><p><strong>样例输出 Sample Output</strong><br>3</p><p><strong>数据范围及提示 Data Size &amp; Hint</strong><br>0≤n≤500000，1≤m≤500000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>所以说，这道题目第一眼看上去是二维树状数组<br>但是再看看数据范围太大了，想到离散化<br>离散化处理还是比较妙的，我们离线找答案，按横坐标排序依次处理。<br>不能用二维树状数组做（尽管带差分然而仍然会炸），于是就直接按两倍的N建立树状数组来做就行了。<br>代码跑得很快，洛谷632ms, 暂时Rank1;<br>然而BZOJ的老机子实在是巨慢无比，居然跑了3300ms左右<br>结果就Rank n了。<br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2500000 + 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y, flag, num;</span><br><span class="line">&#125;;</span><br><span class="line">node a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node q, node w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q.x &lt; w.x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (q.x == w.x) <span class="keyword">return</span> q.num &lt; w.num;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t[MAXN], ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = k; i &lt;= <span class="number">2</span> * N; i += lowbit(i)) ++t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i -= lowbit(i))</span><br><span class="line">res += t[i];</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line"><span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _read()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> c = nc();</span><br><span class="line"><span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = nc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">a = a * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = nc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">N = _read(), M = _read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i].x = _read(), a[i].y = _read(); </span><br><span class="line">a[i].x++, a[i].y++;</span><br><span class="line">a[i].num = a[i].num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> now = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">x1 = _read(), y1 = _read(), x2 = _read(), y2 = _read();</span><br><span class="line">a[++now] = (node)&#123;x1, y1, <span class="number">1</span>, i&#125;;</span><br><span class="line">a[++now] = (node)&#123;x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, <span class="number">1</span>, i&#125;;</span><br><span class="line">a[++now] = (node)&#123;x1, y2 + <span class="number">1</span>, <span class="number">-1</span>, i&#125;;</span><br><span class="line">a[++now] = (node)&#123;x2 + <span class="number">1</span>, y1, <span class="number">-1</span>, i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + now + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= now; ++i)</span><br><span class="line"><span class="keyword">if</span> (!a[i].num)</span><br><span class="line">&#123;</span><br><span class="line">add(a[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans[a[i].num] += a[i].flag * query(a[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><del>话说为了Rank1我tm第一次写了fread的读入优化啊。。</del></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BZOJ </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> CodeVS </tag>
            
            <tag> 离散化 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「洛谷 P1706」全排列</title>
      <link href="/2018/03/31/%E3%80%8C%E6%B4%9B%E8%B0%B7%20P1706%E3%80%8D%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/03/31/%E3%80%8C%E6%B4%9B%E8%B0%B7%20P1706%E3%80%8D%E5%85%A8%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<p>辣鸡题目。直接STL水掉，84ms AC<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) a[i] = i, <span class="built_in">cout</span> &lt;&lt; <span class="string">"    "</span> &lt;&lt; i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (next_permutation(a + <span class="number">1</span>, a + N + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"    "</span> &lt;&lt; a[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 水题 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求乘法逆元</title>
      <link href="/2018/03/31/%E6%B1%82%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
      <url>/2018/03/31/%E6%B1%82%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      <content type="html"><![CDATA[<h1 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h1><h2 id="拓展欧几里得法"><a href="#拓展欧几里得法" class="headerlink" title="拓展欧几里得法"></a>拓展欧几里得法</h2><p>证明不再赘述，直接上我的代码——<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) d = a, x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> exgcd(b, a % b, d, y, x), y -= x * (a / b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll d, x, y;</span><br><span class="line">exgcd(a, p, d, x, y);</span><br><span class="line"><span class="keyword">return</span> d == <span class="number">1</span> ? (x + p) % p : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll a, b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; inv(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>求的是ax≡1(mod p)的逆元</p><h2 id="费马小定理法"><a href="#费马小定理法" class="headerlink" title="费马小定理法"></a>费马小定理法</h2><p>lyj的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; b; (a *= a) %= p, b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) (ans *= a) %= p;</span><br><span class="line"><span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, power(a, p - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「洛谷 P1026」第K小数</title>
      <link href="/2018/03/30/%E3%80%8C%E6%B4%9B%E8%B0%B7%20P1026%E3%80%8D%E7%AC%ACK%E5%B0%8F%E6%95%B0/"/>
      <url>/2018/03/30/%E3%80%8C%E6%B4%9B%E8%B0%B7%20P1026%E3%80%8D%E7%AC%ACK%E5%B0%8F%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>水一波题解。。<br><del>我不会告诉你我没看见输出<code>NO RESULT</code>所以<strong>WA</strong>了两次。。。</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000 + 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, k;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">sort(a + <span class="number">1</span>, a + N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> kth = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != a[i - <span class="number">1</span>]) kth++;</span><br><span class="line"><span class="keyword">if</span> (kth == k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO RESULT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「洛谷 P1510」精卫填海</title>
      <link href="/2018/03/28/%E3%80%8C%E6%B4%9B%E8%B0%B7%20P1510%E3%80%8D%E7%B2%BE%E5%8D%AB%E5%A1%AB%E6%B5%B7/"/>
      <url>/2018/03/28/%E3%80%8C%E6%B4%9B%E8%B0%B7%20P1510%E3%80%8D%E7%B2%BE%E5%8D%AB%E5%A1%AB%E6%B5%B7/</url>
      <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>问题描述</strong></p><p>发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》</p><p>精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？</p><p>事实上，东海未填平的区域还需要至少体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。</p><p><strong>输入输出格式</strong><br><strong>输入格式：</strong><br>输入文件的第一行是三个整数：v、n、c。</p><p>从第二行到第n+1行分别为每块木石的体积和把它衔到东海需要的体力。</p><p><strong>输出格式：</strong><br>输出文件只有一行，如果精卫能把东海填平，则输出她把东海填平后剩下的最大的体力，否则输出’Impossible’（不带引号）。</p><p><strong>输入输出样例</strong><br><strong>输入样例#1： </strong><br>100 2 10<br>50 5<br>50 5<br><strong>输出样例#1： </strong><br>0<br><strong>输入样例#2 </strong><br>10 2 1<br>50 5<br>10 2<br><strong>输出样例#2： </strong><br>Impossible</p><p><strong>数据范围</strong></p><p>对于20%的数据，0&lt;n&lt;=50<br>对于50%的数据，0&lt;n&lt;=1000<br>对于100%的数据，0&lt;n&lt;=10000，所有读入的数均属于[0,10000]，最后结果&lt;=c</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先一眼看上去：这不就是个背包吗？！<br>然后看数据范围，10000.显然我们是无法开这么大的二维数组的<br>所以我们选择压掉一维。<strong>注意，这里很多人有误区是认为时间复杂度也压掉1维，然而这是不太可能的</strong><br>压掉哪一维？显然，最后要求的是最大体力，所以我们选择<strong>剩余体力</strong>作为递推的变量，同时最外层的i枚举石块编号<br>状态转移方程为：<code>f[j] = max(f[j], f[j - m[i]] + v[i])</code><br>核心代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = C; j &gt;= m[i]; j--)</span><br><span class="line">&#123;</span><br><span class="line">f[j] = max(f[j], f[j - m[i]] + v[i]);</span><br><span class="line"><span class="keyword">if</span> (f[j] &gt;= V)</span><br><span class="line">ans = max(ans, C - j), flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面贴出完整AC程序：<del>（挺快的）</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000 + 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> V, N, C, v[MAXN], m[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; V &gt;&gt; N &gt;&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; m[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = C; j &gt;= m[i]; j--)</span><br><span class="line">&#123;</span><br><span class="line">f[j] = max(f[j], f[j - m[i]] + v[i]);</span><br><span class="line"><span class="keyword">if</span> (f[j] &gt;= V)</span><br><span class="line">ans = max(ans, C - j), flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>附：<del>实在佩服自己的瞎BB能力，一道水题可以抛出这么多。。</del></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 水题 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>群作用</title>
      <link href="/2018/03/27/%E7%BE%A4%E4%BD%9C%E7%94%A8/"/>
      <url>/2018/03/27/%E7%BE%A4%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="群作用"><a href="#群作用" class="headerlink" title="群作用"></a>群作用</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>群作用又称为<strong>轨道-中心化子定理</strong><br>数学上，对称群描述物体的所有对称性。这是通过群作用的概念来形式化的：群的每个元素作为一个双射（或者对称作用）作用在某个集合上。在这个情况下，群称为置换群（特别是在群有限或者不是线性空间时）或者变换群（特别是当这个集合是线性空间而群作为线性变换作用在集合上时）。一个群G的置换表示是群作为一个集合的置换群的群表示（通常该集合有限），并且可以表述为置换矩阵，一般在有限的情形作此考虑－这和作用在有序的线性空间基上是一样的。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/qunzuoyong.png" alt=""></p><p><del>本人比较懒，直接从wiki上面搬了</del></p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 抽象代数 </tag>
            
            <tag> 群论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU 3068」最长回文</title>
      <link href="/2018/03/27/%E3%80%8CHDU%203068%E3%80%8D%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/"/>
      <url>/2018/03/27/%E3%80%8CHDU%203068%E3%80%8D%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/</url>
      <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Problem Description</strong><br>给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.<br>回文就是正反读都是一样的字符串,如aba, abba等</p><p><strong>Input</strong><br>输入有多组case,不超过120组,每组输入为一行小写英文字符a,b,c…y,z组成的字符串S<br>两组case之间由空行隔开(该空行不用处理)<br>字符串长度len &lt;= 110000</p><p><strong>Output</strong><br>每一行一个整数x,对应一组case,表示该组case的字符串中所包含的最长回文长度.</p><p><strong>Sample Input</strong><br>aaaa<br>abab</p><p><strong>Sample Output</strong><br>4<br>3</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题是一道<strong>Manachar</strong>模板题</p><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>解决的问题就是：<br>给定一个字符串，求出其最长回文子串。例如：</p><ul><li>s=”abcd”,最长回文长度为 1；</li><li>s=”ababa”,最长回文长度为 5；</li><li>s=”abccb”,最长回文长度为 4，即 bccb。<br>以上问题的传统思路大概是，<strong>遍历每一个字符，以该字符为中点向两边查找</strong>。其时间复杂度为O(n^2)，很不高效，但这个思想我们下面要用到。而在1975年，一个叫<strong>Manacher</strong>的人发明了一个算法，该算法可以把时间复杂度提升到O(n)。下面来看看该算法是如何工作的。</li></ul><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><blockquote><p>以下内容部分摘自<a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008484167</a></p></blockquote><p>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，在字符间插入一个字符（前提这个字符未出现在串里）。举个例子：s=<strong>abbahopxpo</strong>转换为s_new=<strong>$#a#b#b#a#h#o#p#x#p#o#</strong>（这里的字符 <strong>$</strong>; 只是为了<strong>防止越界</strong>，下面代码会有说明），如此，字符串s里起初有一个偶回文<strong>abba</strong>和一个奇回文<strong>opxpo</strong>，被转换为<strong>#a#b#b#a#</strong>和-<strong>#o#p#x#p#o#</strong>，长度都转换成了奇数。</p><p>定义一个辅助数组p，p[i]表示以snew[i]为中心的最长回文的<strong>半径</strong>，例如：<br><img src="/images/sc.png" alt=""><br>可以看出，p[i]-1正好是原字符串中最长回文串的长度。<br>Manacher算法之所以快，就快在对 p 数组的求法上有个捷径。在我们解决了奇偶回文的繁琐时，剩下的难点就是求 p 数组，按照普通思维，我们是这样求解的：求解p[i]，先初始化p[i]=1，再以snew[i]为中心判断两边是否相等，相等就将p[i]+1。这就是之前我们提到的<strong>传统思路</strong>，但是我们想想，能否让p[i]的初始化不是 1，让它更大点，看下图：<br><img src="/images/sc2.png" alt=""></p><p>于是我们可以这样解决：<br>设置两个变量，maxpos 和 id 。maxpos 代表以snew[id]为中心的最长回文最右边界，即为maxpos=id+p[id]。<br>假设我们现在求p[i]，也就是以snew[i]为中心的最长回文半径，如果i &lt; maxpos，如上图，那么p[i] = min(p[2 <em> id - i], mx - i)<br>2 </em> id - i其实就是等于 j ，p[j]表示以s_new[j]为中心的最长回文半径，见上图，因为 i 和 j 关于 id 对称，我们利用p[j]来加快查找。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这样看起来很暴力，为什么复杂度是O(n)的呢？因为maxpos不会减小，每次暴力处理的时候，p[i]增大多少，就说明maxpos增大多少，而maxpos最多增加len次。所以复杂度是O(n)的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码值得注意的是，p数组和snew数组务必要是字符串原串长度的两倍！不然会莫名TLE！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110000 + 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN], snew[<span class="number">2</span> * MAXN];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2</span> * MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">snew[<span class="number">0</span>] = <span class="string">'$'</span>;<span class="comment">//防止在前面越界</span></span><br><span class="line">snew[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">snew[j++] = s[i];</span><br><span class="line">snew[j++] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line">snew[j] = <span class="string">'\0'</span>;<span class="comment">//防止在后面越界</span></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxlen = <span class="number">-1</span>, len = Init();</span><br><span class="line"><span class="keyword">int</span> id, maxpos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; maxpos) p[i] = min(p[id * <span class="number">2</span> - i], maxpos - i);</span><br><span class="line"><span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (snew[i - p[i]] == snew[i + p[i]]) p[i]++;</span><br><span class="line"><span class="keyword">if</span> (maxpos &lt; i + p[i])</span><br><span class="line">id = i, maxpos = i + p[i];</span><br><span class="line">maxlen = max(maxlen, p[i] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) <span class="built_in">cout</span> &lt;&lt; Manacher() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDU </tag>
            
            <tag> 字符串 </tag>
            
            <tag> Manacher </tag>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ 1588」 [HNOI2002]营业额统计</title>
      <link href="/2018/03/26/%E3%80%8CBZOJ%201588%E3%80%8D%20%5BHNOI2002%5D%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1/"/>
      <url>/2018/03/26/%E3%80%8CBZOJ%201588%E3%80%8D%20%5BHNOI2002%5D%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>营业额统计 Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 该天的最小波动值 当最小波动值越大时，就说明营业情况越不稳定。 而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。     输入输出要求</p><p><strong>Input</strong><br>第一行为正整数 ，表示该公司从成立一直到现在的天数，接下来的n行每行有一个整数(有可能有负数) ，表示第i<br>天公司的营业额。<br>天数n&lt;=32767,<br>每天的营业额ai &lt;= 1,000,000。<br>最后结果T&lt;=2^31<br><strong>Output</strong><br>输出文件仅有一个正整数，即Sigma(每天最小的波动值) 。结果小于2^31 。</p><p><strong>Sample Input</strong><br>6<br>5<br>1<br>2<br>5<br>4<br>6</p><p><strong>Sample Output</strong><br>12</p><p><strong>HINT</strong><br>结果说明：5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>模板splay题<br>而且不带删除的<br>发现splay静态的写法比动态的写法好很多：代码复杂度小，而且更快<br>本蒟蒻代码运行结果：<br>Accepted    2844 kb    724 ms    C++/Edit    1971 B<br>表示不是很懂那些几十ms是怎么刷出来的？（也许那时候BZOJ的评测机比较快）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;30)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fa[MAXN], t[MAXN][<span class="number">2</span>], val[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, size, root = <span class="number">0</span>, x1, x2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], l, r;</span><br><span class="line"><span class="keyword">if</span> (t[y][<span class="number">0</span>] == x) l = <span class="number">0</span>; <span class="keyword">else</span> l = <span class="number">1</span>;</span><br><span class="line">r = l ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k == y) k = x;<span class="comment">//如果要旋转到的节点已经是它的父节点，就将要旋转到的节点(通常是根)改为x </span></span><br><span class="line"><span class="keyword">else</span> t[z][t[z][<span class="number">1</span>] == y] = x;<span class="comment">//如果z的右孩子是y，那么就将右孩子改为x，否则将左孩子改为x，右孩子不变 </span></span><br><span class="line">fa[x] = z, fa[y] = x;</span><br><span class="line">fa[t[x][r]] = y; </span><br><span class="line">t[y][l] = t[x][r];</span><br><span class="line">t[x][r] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x != k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line"><span class="keyword">if</span> (y != k)</span><br><span class="line">&#123;</span><br><span class="line">(t[y][<span class="number">0</span>]==x) ^ (t[z][<span class="number">0</span>]==y) ? Rotate(x, k) : Rotate(y, k);</span><br><span class="line">&#125;</span><br><span class="line">Rotate(x, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;k, <span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!k)</span><br><span class="line">&#123;</span><br><span class="line">k = ++size;</span><br><span class="line">val[k] = x, fa[k] = f, Splay(k, root);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val[k] == x) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (x &lt; val[k]) <span class="keyword">return</span> ins(t[k][<span class="number">0</span>], x, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ins(t[k][<span class="number">1</span>], x, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pred</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t[k][<span class="number">0</span>]) <span class="keyword">return</span> ;</span><br><span class="line">k = t[k][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span> (t[k][<span class="number">1</span>]) k = t[k][<span class="number">1</span>];</span><br><span class="line">x1 = val[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!t[k][<span class="number">1</span>]) <span class="keyword">return</span> ;</span><br><span class="line">k = t[k][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (t[k][<span class="number">0</span>]) k = t[k][<span class="number">0</span>];</span><br><span class="line">x2 = val[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (!ins(root, x, <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">x1 = -inf, x2 = inf;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) ans += x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pred(root), succ(root);</span><br><span class="line">ans += min(<span class="built_in">abs</span>(x - x1), <span class="built_in">abs</span>(x2 - x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> BZOJ </tag>
            
            <tag> HNOI </tag>
            
            <tag> Splay </tag>
            
            <tag> 树 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mathematica 解题报告[数学竞赛课？！]</title>
      <link href="/2018/03/24/Mathematica%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2018/03/24/Mathematica%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      <content type="html"><![CDATA[<h1 id="这有可能是你看到的最搞笑的一篇数学解题报告"><a href="#这有可能是你看到的最搞笑的一篇数学解题报告" class="headerlink" title="这有可能是你看到的最搞笑的一篇数学解题报告"></a>这有可能是你看到的最搞笑的一篇数学解题报告</h1><p>题目来源自今天的数学竞赛课</p><ol><li>函数$\sqrt{8x-x^2}-\sqrt{14x-x^2-48}$的最大值是什么？<br>解答：<br><img src="\images\mm3.png" alt=""><br>傻笑））</li></ol><p>2.函数$x+\sqrt{x^2-3x+2}$的值域是什么？<br><img src="\images\mm1.png" alt=""></p><p>3.试求函数$f(x)=x^2+\frac{16}{x}$的单调区间<br>这回没有现成函数。。可惜我们能。。求导！<br><img src="\images\mm4.png" alt=""></p><p>4.函数$f(x)=(3x-1)(\sqrt{9x^2-6x+5}+1)+(2x-3)(\sqrt{4x^2-12x+3}+1)$的图象与x轴的坐标<br>也就是函数值为0嘛。。解个方程。。<br><img src="\images\mm2.png" alt=""></p><p><del>[哎呀我数竞课好想用MMA啊]</del></p>]]></content>
      
      <categories>
          
          <category> 无聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> MMA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ 4520」[CQOI2016]K远点对</title>
      <link href="/2018/03/22/%E3%80%8CBZOJ%204520%E3%80%8D%5BCQOI2016%5DK%E8%BF%9C%E7%82%B9%E5%AF%B9/"/>
      <url>/2018/03/22/%E3%80%8CBZOJ%204520%E3%80%8D%5BCQOI2016%5DK%E8%BF%9C%E7%82%B9%E5%AF%B9/</url>
      <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>已知平面内 N 个点的坐标，求欧氏距离下的第 K 远点对。</p><p><strong>Input</strong><br>输入文件第一行为用空格隔开的两个整数 N， K。接下来 N 行，每行两个整数 X,Y，表示一个点<br>的坐标。1 &lt; =  N &lt; =  100000， 1 &lt; =  K &lt; =  100， K &lt; =  N*(N−1)/2 ， 0 &lt; =  X, Y &lt; 2^31。<br><strong>Output</strong><br>输出文件第一行为一个整数，表示第 K 远点对的距离的平方（一定是个整数）。</p><p><strong>Sample Input</strong><br>10 5<br>0 0<br>0 1<br>1 0<br>1 1<br>2 0<br>2 1<br>1 2<br>0 2<br>3 0<br>3 1<br><strong>Sample Output</strong><br>9</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这题是KDTree模板题啊Orzzz<br>然额本蒟蒻打了好久才调出来<br>原因：<br><img src="/images/zz.png" alt=""></p><p>简直了。。<br>附上蒟蒻代码：（太懒没时间打注释）<br>跑的实在是巨慢：<br><img src="/images/status1.png" alt=""><br>顺便说一句：那个MAX和MIN记录的是<strong>当前矩阵区域内最大的横纵坐标值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100011</span></span><br><span class="line"><span class="keyword">int</span> N, K, nowD, root, ql, qr; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.dis &lt; dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">KDTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2</span>], Min[<span class="number">2</span>], Max[<span class="number">2</span>], l, r;</span><br><span class="line">&#125; KDT;</span><br><span class="line">KDT Tree[MAXN];</span><br><span class="line">priority_queue &lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sqr</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MAX</span><span class="params">(KDT &amp;a, KDT b, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.Max[type] = max(a.Max[type], b.Max[type]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MIN</span><span class="params">(KDT &amp;a, KDT b, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.Min[type] = min(a.Min[type], b.Min[type]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">GetDis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sqr(Tree[x].d[<span class="number">0</span>] - Tree[y].d[<span class="number">0</span>]) + sqr(Tree[y].d[<span class="number">1</span>] - Tree[x].d[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(KDT a, KDT b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.d[nowD] == b.d[nowD])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.d[nowD ^ <span class="number">1</span>] &lt; b.d[nowD ^ <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.d[nowD] &lt; b.d[nowD];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree[x].l) <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) MAX(Tree[x], Tree[Tree[x].l], i), MIN(Tree[x], Tree[Tree[x].l], i);</span><br><span class="line"><span class="keyword">if</span> (Tree[x].r) <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) MAX(Tree[x], Tree[Tree[x].r], i), MIN(Tree[x], Tree[Tree[x].r], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nowD = D;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">nth_element(Tree + l + <span class="number">1</span>, Tree + mid + <span class="number">1</span>, Tree + r + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) Tree[mid].l = Build(l, mid - <span class="number">1</span>, D ^ <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (mid &lt; r) Tree[mid].r = Build(mid + <span class="number">1</span>, r, D ^ <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">Tree[mid].Min[i] = Tree[mid].Max[i] = Tree[mid].d[i];</span><br><span class="line">Update(mid);</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Adis</span><span class="params">(KDT A, KDT B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> max(sqr(A.d[<span class="number">0</span>] - B.Min[<span class="number">0</span>]), sqr(A.d[<span class="number">0</span>] - B.Max[<span class="number">0</span>])) + max(sqr(A.d[<span class="number">1</span>] - B.Min[<span class="number">1</span>]), sqr(A.d[<span class="number">1</span>] - B.Max[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dl = <span class="number">0</span>, dr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis = GetDis(<span class="number">0</span>, x);</span><br><span class="line"><span class="keyword">if</span> (dis &gt; Q.top().dis)</span><br><span class="line">&#123;</span><br><span class="line">Q.pop();</span><br><span class="line">Q.push((node)&#123; dis &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Tree[x].l) dl = Adis(Tree[<span class="number">0</span>], Tree[Tree[x].l]);</span><br><span class="line"><span class="keyword">if</span> (Tree[x].r) dr = Adis(Tree[<span class="number">0</span>], Tree[Tree[x].r]);</span><br><span class="line"><span class="keyword">if</span> (dl &gt; dr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dl &gt; Q.top().dis) Query(Tree[x].l);</span><br><span class="line"><span class="keyword">if</span> (dr &gt; Q.top().dis) Query(Tree[x].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dr &gt; Q.top().dis) Query(Tree[x].r);</span><br><span class="line"><span class="keyword">if</span> (dl &gt; Q.top().dis) Query(Tree[x].l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>); </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Tree[i].d[<span class="number">0</span>] &gt;&gt; Tree[i].d[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">root = Build(<span class="number">1</span>, N, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K * <span class="number">2</span>; ++i)</span><br><span class="line">Q.push((node) &#123; <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">Tree[<span class="number">0</span>].d[<span class="number">0</span>] = Tree[i].d[<span class="number">0</span>];</span><br><span class="line">Tree[<span class="number">0</span>].d[<span class="number">1</span>] = Tree[i].d[<span class="number">1</span>];</span><br><span class="line">Query(root); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Q.top().dis &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> BZOJ </tag>
            
            <tag> KD树 </tag>
            
            <tag> CQOI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeVS 1369」xth砍树</title>
      <link href="/2018/03/18/%E3%80%8CCodeVS%201369%E3%80%8Dxth%E7%A0%8D%E6%A0%91/"/>
      <url>/2018/03/18/%E3%80%8CCodeVS%201369%E3%80%8Dxth%E7%A0%8D%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1369/" target="_blank" rel="noopener">传送门</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>题目描述 Description</strong><br>在一个凉爽的夏夜，xth 和 rabbit 来到花园里砍树。为啥米要砍树呢？是这样滴，<br>小菜儿的儿子窄森要出生了。Xth这个做伯伯的自然要做点什么。于是他决定带着<br>rabbit 去收集一些木材，给窄森做一个婴儿车……（xth 早就梦想着要天天打菜儿<br>他儿窄森的小 pp，到时候在婴儿车里安装一个电子遥控手臂，轻轻一按，啪啪<br>啪……“乌卡卡——”xth 邪恶滴笑了，“不要告诉 rabbit，她会说我缺德的……”<br>xth 如是说）。<br>花园里共有n棵树。为了花园的整体形象，rabbit 要求 xth只能在m个区域砍伐，我<br>们可以将这m个区域看成m个区间，树的间距相等，都是1，我们将每个区间设为<br>[x, y]。那么长度为k的区间中就有k棵树。树木的高度不等。现在 xth 想测量一下，<br>每个区间树木砍伐后所得的木材量是多少，而且每次测量后他都会砍下标号为<br>(x+y)/2<br>的那棵作为纪念。以方便他安排人手。(同一个区间的树木可以重复砍伐，我们认<br>为被砍过的树木高度为0)<br>每棵树的木材量=树的高度∗ 3.14（注意是3.14不是π）。</p><p><strong>输入描述 Input Description</strong><br>第一行，一个整数n。<br>第二行，共n个整数，表示每棵树的高度。<br>第三行，一个整数m，表示共m个区间。<br>以下m行，每个区间[x, y]的左右端点x, y。</p><p><strong>输出描述 Output Description</strong><br>共m行，每行一个数，表示每个区间的木材量。</p><p>结果精确到小数点后两位。</p><p><strong>样例输入 Sample Input</strong><br>5<br>1 2 3 4 5<br>2<br>1 4<br>2 4</p><p><strong>样例输出 Sample Output</strong><br>31.40<br>21.98</p><p><strong>数据范围及提示 Data Size &amp; Hint</strong><br>对于30%的数据，有n ≤ 5000,m ≤ 5000;<br>对于100%的数据，有n ≤ 200000,m ≤ 200000;</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这是我见过的废话最多的题目之一。。。。<br>树状数组或线段树均可以过，反正都是单点修改区间查询即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200000 + 5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], c[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = pos; i &lt;= N; i += lowbit(i)) c[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = pos; i &gt;= <span class="number">1</span>; i -= lowbit(i)) ret += c[i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">Modify(i, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; M;</span><br><span class="line"><span class="keyword">while</span> (M--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,<span class="number">3.14</span> * (query(r) - query(l - <span class="number">1</span>)));</span><br><span class="line">Modify((l + r) &gt;&gt; <span class="number">1</span>, -a[(l + r) &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">a[(l + r) &gt;&gt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> CodeVS </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU 1556」Color the ball</title>
      <link href="/2018/03/17/%E3%80%8CHDU%201556%E3%80%8DColor%20the%20ball/"/>
      <url>/2018/03/17/%E3%80%8CHDU%201556%E3%80%8DColor%20the%20ball/</url>
      <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1556" target="_blank" rel="noopener">传送门</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><strong>Problem Description</strong><br>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？</p><p><strong>Input</strong><br>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>当N = 0，输入结束。</p><p><strong>Output</strong><br>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p><p><strong>Sample Input</strong><br>3<br>1 1<br>2 2<br>3 3<br>3<br>1 1<br>1 2<br>1 3<br>0</p><p><strong>Sample Output</strong><br>1 1 1<br>3 2 1</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>一道非常非常经典的题目，就是区间染色问题<br>一个线段树解决即可。<br>（突然发现以前写过这道题，但是这次写比以前快了若干毫秒。<br>代码风格差异不大吧。。。）<br>现在的代码：（没有注释）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Segt Tree[MAXN * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Tree[ind].cnt = <span class="number">0</span>, Tree[ind].l = l, Tree[ind].r = r;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">Build(ind &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">Build(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].l == l &amp;&amp; Tree[ind].r == r)</span><br><span class="line">&#123;</span><br><span class="line">Tree[ind].cnt++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].l == Tree[ind].r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (Tree[ind].l + Tree[ind].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &lt; l)</span><br><span class="line">&#123;</span><br><span class="line">Modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (mid &gt;= r)</span><br><span class="line">&#123;</span><br><span class="line">Modify(ind &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Modify(ind &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">Modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].l == l &amp;&amp; Tree[ind].r == r)</span><br><span class="line"><span class="keyword">return</span> Tree[ind].cnt;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].l == Tree[ind].r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (Tree[ind].l + Tree[ind].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Tree[ind].cnt + Calc(ind &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">if</span> (mid &lt; l)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Tree[ind].cnt + Calc(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Tree[ind].cnt + Calc(ind &lt;&lt; <span class="number">1</span>, l, mid) + Calc(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">SegTree A;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">while</span> (N != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">A.Build(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">A.Modify(<span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A.Calc(<span class="number">1</span>, i, i);</span><br><span class="line">i == N ? <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>话说线段树空间一定要开满4倍。。。就因为这个于是就RE了一次（泪奔</p><p>这是以前的代码，注释还真挺多的，就是慢了（可能没有用位运算吧）<del>（当时我要写给谁来着[黑人问号]）</del><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> lc, rc, cnt;<span class="comment">//cnt:被涂过的次数</span></span><br><span class="line">&#125; SegTree[MAXN * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SegTree[root].cnt = <span class="number">0</span>, SegTree[root].lc = left, SegTree[root].rc = right;<span class="comment">//初始化当前节点</span></span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span>;<span class="comment">//找到最小区间，退出递归</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//中间值mid，方便书写</span></span><br><span class="line">Build(root * <span class="number">2</span>, left, mid);<span class="comment">//递归初始化左子树</span></span><br><span class="line">Build(root * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right);<span class="comment">//递归初始化右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><span class="comment">//更新某一区间的值，即染色</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SegTree[root].lc == left &amp;&amp; SegTree[root].rc == right)<span class="comment">//找到要更新的区间</span></span><br><span class="line">&#123;</span><br><span class="line">SegTree[root].cnt++;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//更新该值，退出递归</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SegTree[root].lc == SegTree[root].rc) <span class="keyword">return</span>;<span class="comment">//没有找到</span></span><br><span class="line"><span class="keyword">int</span> mid = (SegTree[root].lc + SegTree[root].rc) / <span class="number">2</span>;<span class="comment">//注意不是(left + right) / 2</span></span><br><span class="line"><span class="keyword">if</span> (mid &lt; left) Update(root * <span class="number">2</span> + <span class="number">1</span>, left, right);<span class="comment">//比当前最左边的范围还要小，去右子树找</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &gt;= right) Update(root * <span class="number">2</span>, left, right);<span class="comment">//比当前最右边的范围还要小，去左子树找</span></span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//中点在要查询区间的中间,两边都要找</span></span><br><span class="line">Update(root * <span class="number">2</span>, left, mid);</span><br><span class="line">Update(root * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>    <span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (SegTree[root].lc == left &amp;&amp; SegTree[root].rc == right) <span class="keyword">return</span> SegTree[root].cnt;<span class="comment">//找到区间</span></span><br><span class="line"><span class="keyword">if</span> (SegTree[root].lc == SegTree[root].rc) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没有找到</span></span><br><span class="line"><span class="keyword">int</span> mid = (SegTree[root].lc + SegTree[root].rc) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= right) <span class="keyword">return</span> SegTree[root].cnt + Query(root * <span class="number">2</span>, left, right);<span class="comment">//去左子树寻找</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; left) <span class="keyword">return</span> SegTree[root].cnt + Query(root * <span class="number">2</span> + <span class="number">1</span>, left, right);<span class="comment">//去右子树寻找</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> SegTree[root].cnt + Query(root * <span class="number">2</span>, left, mid) + Query(root * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right);<span class="comment">//中点在要查询区间的中间,两边都要找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> N, A, B, sum;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">while</span> (N)</span><br><span class="line">&#123;</span><br><span class="line">Build(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">Update(<span class="number">1</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ans = Query(<span class="number">1</span>, i, i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">if</span> (i == N) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> HDU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段统计 - 线段树懒标记</title>
      <link href="/2018/03/17/%E7%BA%BF%E6%AE%B5%E7%BB%9F%E8%AE%A1%20-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%87%92%E6%A0%87%E8%AE%B0/"/>
      <url>/2018/03/17/%E7%BA%BF%E6%AE%B5%E7%BB%9F%E8%AE%A1%20-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%87%92%E6%A0%87%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="线段统计-线段树懒标记"><a href="#线段统计-线段树懒标记" class="headerlink" title="线段统计 - 线段树懒标记"></a>线段统计 - 线段树懒标记</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p><strong>题目描述</strong><br>在数轴上进行一系列操作。每次操作有两种类型，一种是在线段[a,b]上涂上颜色，另一种将[a,b]上的颜色擦去。问经过一系列的操作后，有多少条单位线段[k,k+1]被涂上了颜色。</p><p><strong>输入格式</strong><br>第1行：2个整数n（0&lt;=n&lt;=60000）和m（1&lt;=m&lt;=60000）分别表示数轴长度和进行操作的次数。<br>接下来m行，每行3个整数i，a，b， 0 &lt;=a&lt;=b&lt;=60000，若i=1表示给线段[a,b]上涂上颜色，若i=2表示将[a,b]上的颜色擦去。</p><p><strong>输出格式</strong><br>文件输出仅有一行为1个整数，表示有多少条单位线段[k,k+1]被涂上了颜色。</p><p><strong>样例输入</strong><br>10 5<br>1 2 8<br>2 3 6<br>1 1 10<br>2 4 7<br>1 1 5</p><p><strong>样例输出</strong><br>7</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最为经典的一道区间修改区间查询加懒标记的题了<br>懒标记的实质：推迟信息更新，避免无用操作<br>如果不加懒标记，线段树连暴力都不如。<br>对于每个非完全包含的区间，在修改和查询到的时候都要向下传标记。<br>比如此题，如果标记为全部有色，传下去儿子结点全部有色，全部无色亦然。<br>传完标记后需要将标记置为0表示儿子中有的有颜色有的无颜色。<br>因为建树方式不同，线段映射到点右端点需-1</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, colored, lazy;</span><br><span class="line"><span class="comment">//lazy=1表示该区间内全部染了色 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Segt Tree[MAXN * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Tree[ind].l = l, Tree[ind].r = r;</span><br><span class="line">Tree[ind].colored = <span class="number">0</span>, Tree[ind].lazy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">Build(ind &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">Build(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PD</span><span class="params">(<span class="keyword">int</span> ind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].lazy == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Tree[ind &lt;&lt; <span class="number">1</span>].lazy = Tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = <span class="number">-1</span>;</span><br><span class="line">Tree[ind &lt;&lt; <span class="number">1</span>].colored = Tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].colored = <span class="number">0</span>;</span><br><span class="line">Tree[ind].lazy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].lazy == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Tree[ind &lt;&lt; <span class="number">1</span>].lazy = Tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = <span class="number">1</span>;</span><br><span class="line">Tree[ind &lt;&lt; <span class="number">1</span>].colored = Tree[ind &lt;&lt; <span class="number">1</span>].r - Tree[ind &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>;</span><br><span class="line">Tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].colored = Tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - Tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span>;</span><br><span class="line">Tree[ind].lazy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PU</span><span class="params">(<span class="keyword">int</span> ind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Tree[ind].colored = Tree[ind &lt;&lt; <span class="number">1</span>].colored + Tree[ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].colored;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> ind, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ope)</span><span class="comment">//Ope:Operations:1-&gt;color,2-&gt;discolor</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].l &gt; r || Tree[ind].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (Tree[ind].lazy == ope) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= Tree[ind].l &amp;&amp; Tree[ind].r &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">Tree[ind].lazy = ope;</span><br><span class="line"><span class="keyword">if</span> (ope == <span class="number">-1</span> || ope == <span class="number">0</span>) Tree[ind].colored = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> Tree[ind].colored = Tree[ind].r - Tree[ind].l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">PD(ind);</span><br><span class="line">Modify(ind &lt;&lt; <span class="number">1</span>, l, r, ope);</span><br><span class="line">Modify(ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, ope);</span><br><span class="line">PU(ind);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">SegmentTree st;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">st.Build(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ope, l, r;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ope &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">if</span> (ope == <span class="number">1</span>) st.Modify(<span class="number">1</span>, l, r - <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//记得这边要是r - 1 </span></span><br><span class="line"><span class="keyword">else</span> st.Modify(<span class="number">1</span>, l, r - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st.Tree[<span class="number">1</span>].colored &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 懒标记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性基</title>
      <link href="/2018/03/12/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2018/03/12/%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      <content type="html"><![CDATA[<h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>设数集$T$的范围为$[1,2^n−1]$。<br>$T$的线性基是$T$的一个子集$A=\{a1,a2,a3,…,an\}$。<br>$A$中元素互相$xor$所形成的异或集合，等价于原数集$T$的元素互相$xor$形成的异或集合。<br>$A$可以看成是$T$的压缩。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>线性基有一些性质：</p><ul><li>线性基的异或集合中不存在$0$。也就是说，$A$是$T$中的<a href="https://baike.baidu.com/item/%E6%9E%81%E5%A4%A7%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3%E7%BB%84/11035667?fr=aladdin" target="_blank" rel="noopener">极大线性无关组</a>，同时$A⊆T$。</li><li>线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。这个与性质1其实是等价的。</li><li>线性基的二进制最高位互不相同。</li><li>如果线性基是满的，它的异或集合为$\{1,2,3…2^n-1\}$。</li><li>线性基中元素互相异或，异或集合不变。</li></ul><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>如果向线性基中插入数$x$，从高位到低位扫描它为1的二进制位。<br>扫描到第$i$位时，如果$a_i$不存在，就令$a_i=x$，否则$x=x⊗a_i$。<br>$x$的结局是，要么被扔进线性基，要么经过一系列操作过后，变成了$0$。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>将一个线性基暴力插入另一个线性基即可。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><p>从高位到低位扫描线性基。<br>如果异或后可以使得答案变大，就异或到答案中去。</p><h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><p>最小值即为最低位上的线性基。</p><h4 id="k小值"><a href="#k小值" class="headerlink" title="k小值"></a>k小值</h4><p>根据性质3。<br>我们要将线性基改造成每一位相互独立。<br>具体操作就是如果i&lt;j，$a_j$的第$i$位是$1$，就将$a_j$异或上$a_i$。<br>经过一系列操作之后，对于二进制的某一位$i$。只有$a_i$的这一位是$1$，其他都是$0$。<br>所以查询的时候将$k$二进制拆分，对于$1$的位，就异或上对应的线性基。<br>最终得出的答案就是$k$小值。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><strong>样例输入</strong><br>一个整数N，后面N行待插入的数值<br>6<br>5<br>23<br>4<br>12<br>2<br>9<br><strong>样例输出</strong><br>一个最大的xor值和一个最小的xor值<br>31 1<br>下面给出完整模板：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fordowni for (register int i = 60; i &gt;= 0;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forupi for (register int i = 0; i &lt;= 60;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">61</span>], p[<span class="number">61</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line">LinearBase()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Fordowni</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val &amp; (<span class="number">1l</span>l &lt;&lt; i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!d[i])</span><br><span class="line">&#123;</span><br><span class="line">d[i] = val;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">val ^= d[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Querymax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">Fordowni</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((res ^ d[i]) &gt; res)</span><br><span class="line">res ^= d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Querymin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">Forupi<span class="comment">//这边不要写成Fordowni </span></span><br><span class="line"><span class="keyword">if</span> (d[i])</span><br><span class="line"><span class="keyword">return</span> d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Fordowni</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &amp; (<span class="number">1l</span>l &lt;&lt; j))</span><br><span class="line">&#123;</span><br><span class="line">d[i] ^= d[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Forupi</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i])</span><br><span class="line">p[cnt++] = d[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthquery</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rebuild();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt;= (<span class="number">1l</span>l &lt;&lt; cnt))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">Fordowni</span><br><span class="line"><span class="keyword">if</span> (k &amp; (<span class="number">1l</span>l &lt;&lt; i))<span class="comment">//不同的写法：(k &gt;&gt; i) &amp; 1 </span></span><br><span class="line">ret ^= p[i];</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">LinearBase <span class="title">merge</span><span class="params">(<span class="keyword">const</span> LinearBase &amp;n1,<span class="keyword">const</span> LinearBase &amp;n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinearBase ret = n1;</span><br><span class="line">    Fordowni</span><br><span class="line">        <span class="keyword">if</span> (n2.d[i])</span><br><span class="line">            ret.insert(n2.d[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">LinearBase A;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">A.insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A.Querymax() &lt;&lt; <span class="string">" "</span> &lt;&lt; A.Querymin() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蒟蒻分层赛之T1解题报告</title>
      <link href="/2018/03/11/%E8%92%9F%E8%92%BB%E5%88%86%E5%B1%82%E8%B5%9B%E4%B9%8BT1%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2018/03/11/%E8%92%9F%E8%92%BB%E5%88%86%E5%B1%82%E8%B5%9B%E4%B9%8BT1%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      <content type="html"><![CDATA[<h1 id="跳马-horse"><a href="#跳马-horse" class="headerlink" title="跳马(horse)"></a>跳马(horse)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>基本信息</strong><br>英文题目名称    horse<br>输入文件名    horse.in<br>输出文件名    horse.out<br>每个测试点时限    1S<br>测试点数目    10<br>每个测试点分值    10<br>内存限制    256MB<br>题目类型    传统<br><strong>编译选项</strong><br>对于C++语言    -O2 -lm<br>对于C语言    -O2 -lm<br>对于Pascal语言    -O2</p><p><strong>题目描述</strong><br>一个骑士在一个无限大的国际象棋棋盘里跳。一开始，这个国际象棋棋盘的每一个格子都是被标记为未被走过的，而骑士一开始可以以任意的一个格子作为起点，并且这个格子标记为走过。然后，他可以以如下图的规则跳N次，每一个他所到过的格子都会被标记为已经走过。<br><img src="/images/horse.jpg" alt=""><br>现在，我们需要知道在N次跳跃之后，有多少个格子可能被标记为走过。<br><strong>输入</strong><br>第一行一个整数T，表示数据组数<br>接下来T行，每行一个整数N<br><strong>输出</strong><br>共T行，每行一个整数，表示对应测试数据的答案<br><strong>样例输入</strong><br>3<br>0<br>1<br>7<br><strong>样例输出</strong><br>1<br>9<br>649<br><strong>数据规模</strong><br>对于30%的数据，1&lt;=T&lt;=10，N&lt;=1,000<br>对于60%的数据，1&lt;=T&lt;=100，N&lt;=1,000,000<br>对于100%的数据，1&lt;=T&lt;=100,000，N&lt;=1,000,000,000</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>第一眼看上去：嗯，计数问题嘛，看上去好水。。<br>第二眼看上去：卧槽？好像不是那么回事？<br>第三眼看上去：妈卖批啊怎么推</p><ul><li>正解居然是：<strong>打表找规律！</strong></li></ul><p>又想起了那句经典的老话：数论推个屁，打表找规律。。。<br>是那么回事吗？<br>我们看看打表的情况<br>$1,9,41,109,205,325,473,649,853,1085,1345…$<br>前后相减？一点毛线规律都没有啊。。<br>要不从后往前看看（鬼知道要从后往前看），最后增量都是…28?<br>到底是在哪里不是28了呢（寻找ing）<br>哦，原来是$N=5$是分解线啊，mmp。。。</p><p>然后前几项我哦们自然而然把表填上去好了，后面的话，增量相同，然后我们又会<del>自然而然</del>的想到这是个二次函数<br>求一下。。还真是<br>N&gt;=6时的通项公式为$A_i=14i^2-6i+5$</p><p>随后我们的程序就显而易见了。。（去你的显而易见</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">6</span>] = &#123; <span class="number">1</span>,<span class="number">9</span>,<span class="number">41</span>,<span class="number">109</span>,<span class="number">205</span>,<span class="number">325</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"horse.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"horse.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x, ans; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">6</span>) ans = a[x];</span><br><span class="line"><span class="keyword">else</span> ans = <span class="number">14</span> * x * x - <span class="number">6</span> * x + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 智商题 </tag>
            
            <tag> 打表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ 2006」[NOI2010]超级钢琴</title>
      <link href="/2018/03/10/%E3%80%8CBZOJ%202006%E3%80%8D%5BNOI2010%5D%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/"/>
      <url>/2018/03/10/%E3%80%8CBZOJ%202006%E3%80%8D%5BNOI2010%5D%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/</url>
      <content type="html"><![CDATA[<h1 id="NOI2010-超级钢琴"><a href="#NOI2010-超级钢琴" class="headerlink" title="[NOI2010]超级钢琴"></a>[NOI2010]超级钢琴</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>Description</strong><br>小Z是一个小有名气的钢琴家，最近C博士送给了小Z一架超级钢琴，小Z希望能够用这架钢琴创作出世界上最美妙的音乐。 这架超级钢琴可以弹奏出$n$个音符，编号为$1$至$n$。第i个音符的美妙度为Ai，其中Ai可正可负。 一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于L且不多于R。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。 小Z决定创作一首由k个超级和弦组成的乐曲，为了使得乐曲更加动听，小Z要求该乐曲由k个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小Z想知道他能够创出来的乐曲美妙度最<br>大值是多少。<br><strong>Input</strong><br>第一行包含四个正整数n, k, L, R。其中n为音符的个数，k为乐曲所包含的超级和弦个数，L和R分别是超级和弦所<br>包含音符个数的下限和上限。 接下来n行，每行包含一个整数Ai，表示按编号从小到大每个音符的美妙度。<br>N&lt;=500,000<br>k&lt;=500,000<br>-1000&lt;=$A_i$&lt;=1000,1&lt;=L&lt;=R&lt;=N且保证一定存在满足条件的乐曲<br>Output<br>只有一个整数，表示乐曲美妙度的最大值。</p><p><strong>Sample Input</strong><br>4 3 2 3<br>3<br>2<br>-6<br>8<br><strong>Sample Output</strong><br>11</p><p>【样例说明】</p><p>共有5种不同的超级和弦：<br>音符1 ~ 2，美妙度为3 + 2 = 5<br>音符2 ~ 3，美妙度为2 + (-6) = -4<br>音符3 ~ 4，美妙度为(-6) + 8 = 2<br>音符1 ~ 3，美妙度为3 + 2 + (-6) = -1<br>音符2 ~ 4，美妙度为2 + (-6) + 8 = 4<br>最优方案为：乐曲由和弦1，和弦3，和弦5组成，美妙度为5 + 2 + 4 = 11。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先考虑如果k=1的时候如何来做。当k=1时，也就是只选出来一个最大值就可以了，我们可以枚举区间的起点，每一个起点对应的一个区间长度合法的区间，从这段区间里找出来一个前缀和最大的然后减去起点的就可以了。<br>但是如果k&gt;1的话，我们不能只找一个最大的。那么可以考虑维护一个大根堆，每次弹出堆中最大的元素来，弹k次。每次找出来一个最大值，然后压到堆里。每次从堆中弹出一个最大的，这个最大的还记录的一些信息：起点head，合法区间的lr，以及取最大值的位置loc，那么找出这个最大值之后计入答案，然后再将同样是head为起点，[l,loc-1]和[loc+1,r]的最大值压入堆。这样就贪心地找出了前k大的。时间复杂度$O(klogn)$。</p><p>一样给大家附上了<del>精美</del>的代码。。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500000 + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXexpo 30</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val, loc, l, r, head;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> HeapNode &amp;a) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; a.val;<span class="comment">//这玩意不能写反</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span> <span class="title">HN</span>;</span></span><br><span class="line"><span class="keyword">int</span> N, k, l, r;</span><br><span class="line"><span class="keyword">int</span> data[MAXN], sum[MAXN];</span><br><span class="line">HN f[MAXN][MAXexpo];</span><br><span class="line">priority_queue &lt;HN&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">f[i][<span class="number">0</span>].val = sum[i], f[i][<span class="number">0</span>].loc = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; MAXexpo; ++j)<span class="comment">//这边要预处理一直到MAXexpo，而不能仅仅预处理到log n</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span>&lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> HN <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = log2(r - l + <span class="number">1</span>);<span class="comment">//后来发现log2原来是个STL啊。。</span></span><br><span class="line"><span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">HN now = query(l, r);</span><br><span class="line">now.val -= sum[head - <span class="number">1</span>], now.l = l, now.r = r, now.head = head;</span><br><span class="line">    <span class="comment">//先计算前缀和</span></span><br><span class="line">que.push(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; k &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + data[i];</span><br><span class="line">&#125;</span><br><span class="line">initst();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i + l - <span class="number">1</span> &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> Left = min(i + l - <span class="number">1</span>, N);</span><br><span class="line"><span class="keyword">int</span> Right = min(i + r - <span class="number">1</span>, N);</span><br><span class="line">Add(Left, Right, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;<span class="comment">//一定要记得初始化赋值啊。。</span></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line">HN now = que.top();<span class="comment">//每次弹出一个最大值</span></span><br><span class="line">que.pop();</span><br><span class="line">ans += (<span class="keyword">long</span> <span class="keyword">long</span>)now.val;</span><br><span class="line">Add(now.l, now.loc - <span class="number">1</span>, now.head);</span><br><span class="line">Add(now.loc + <span class="number">1</span>, now.r, now.head);<span class="comment">//把区间中的最大值继续压入堆中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ST表 </tag>
            
            <tag> BZOJ </tag>
            
            <tag> NOI </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ST表详解</title>
      <link href="/2018/03/08/ST%E8%A1%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/08/ST%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>ST算法是用来求解给定区间的最值的</li></ul><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul><li>ST算法分成两部分：离线预处理 $O(nlogn)$和 在线查询$O(1)$。虽然还可以使用线段树、树状链表等求解区间最值，但是ST算法要比它们更快，而且适用于在线查询。</li></ul><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li>就是DP， 用于求解区间最值，并保存到一个二维数组中</li><li>使用倍增的思想，每次增加2^i个长度<br>使用$f[i,j]$表示以$i$为起点，区间长度为$2^j$的区间最值，此时区间为$[i,i + 2^j - 1]$。<br>比如，$f[0,2]$表示区间$[0,3]$的最小值，即等于$4$，$f[2,2]$表示区间$[2,5]$的最小值，即等于$1$。<br>在求解$f[i,j]$时，ST算法先对长度为$2^j$的区间$[i,i + 2^j - 1]$分成两等份，每份长度均为$2^{j - 1}$。之后在分别求解这两个区间的最值$f[i,j - 1]$和$f[i + 2^{j - 1},j - 1]$。，最后在结合这两个区间的最值，求出整个区间的最值。特殊情况，当$j = 0$时，区间长度等于$1$，即区间中只有一个元素，此时$f[i,0]$应等于每一个元素的值。<br>举例：要求解$f[1,2]$的值，即求解区间$[1,4] = \{4,6,10,1\}$的最小值，此时需要把这个区间分成两个等长的区间，即为$[1,2]$和$[3,4]$，之后分别求解这两个区间的最小值。此时这两个区间最小值分别对应着$f[1,1]$ 和 $f[3,1]$的值。<br>状态转移方程: $f[i,j] = min(f[i,j - 1],f[i + 2^{j-1},j - 1])$<br>初始状态为：$f[i,0] = data[i]$</li></ul><h2 id="求最值"><a href="#求最值" class="headerlink" title="求最值"></a>求最值</h2><p>已知待查询的区间$[x,y]$，求最值</p><p>我们把待查询的区间分成<strong>两个小区间</strong>，这两个小区间满足两个条件：<br>（1）这两个小区间要能覆盖整个区间<br>（2）为了利用预处理的结果，要求小区间长度相等且都为$2^i$。注意两个小区间可能重叠。</p><p>我们可以直接得到两段区间的$i=log_2^{l-r+1}$</p><p>把待查询区间$[x，y]$分成两个小区间$[x，x + 2^i - 1]$ 和 $[y - 2^i + 1，y]$，其又分别对应着$f[x,i]$和$f[y - 2^i + 1,i]$，此时为了求解整个区间的最小值，我们只需求这两个值得最小值即可，此时复杂度是$O(1)$。</p><p>下面给出完整的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sparse_Table ST</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparse_Table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 233333</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAXEXPO 32</span></span><br><span class="line">    <span class="comment">//这边列表示2的幂次，32足够int类型使用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> QMax[MAXN][MAXEXPO];</span><br><span class="line"><span class="keyword">int</span> QMin[MAXN][MAXEXPO];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> data[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">log2</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">log</span>(a) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initST</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">2</span> &lt;&lt; j) &lt;&lt; N; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">QMax[i][j] = max(QMax[i][j - <span class="number">1</span>], QMax[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);<span class="comment">//一定要注意是(1&lt;&lt;(j-1)),表示2^(j-1)</span></span><br><span class="line">QMin[i][j] = min(QMin[i][j - <span class="number">1</span>], QMin[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMin</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = log2(<span class="built_in">abs</span>(r - l + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> min(QMin[l][k], QMin[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMax</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = log2(<span class="built_in">abs</span>(r - l + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> max(QMax[l][k], QMax[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ST A;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; A.N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.N; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; A.data[i];</span><br><span class="line">A.initST();</span><br><span class="line"><span class="keyword">int</span> Queries;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your number of queries:"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Queries;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Queries; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MAXINUM Between "</span> &lt;&lt; x &lt;&lt; <span class="string">" and "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; A.QueryMax(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MININUM Between "</span> &lt;&lt; x &lt;&lt; <span class="string">" and "</span> &lt;&lt; y &lt;&lt; <span class="string">" is "</span> &lt;&lt; A.QueryMin(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> ST表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++求解N阶幻方</title>
      <link href="/2018/03/07/C++%E6%B1%82%E8%A7%A3N%E9%98%B6%E5%B9%BB%E6%96%B9/"/>
      <url>/2018/03/07/C++%E6%B1%82%E8%A7%A3N%E9%98%B6%E5%B9%BB%E6%96%B9/</url>
      <content type="html"><![CDATA[<p>由一道数学题的联想<br>然后根据网上的做法<del>瞎jb乱打</del>了一下，居然对了<br>代码<del>精心</del>附上了注释，有兴趣的童鞋可以看一看。。<br>不说了，上代码！(自认为结构很<del>清晰易懂</del>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> matrix[MAXN][MAXN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//生成奇数幻方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateOddMagicSquare</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y, mun = <span class="number">1</span>;</span><br><span class="line">y = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mun &lt;= n * n)</span><br><span class="line">&#123;</span><br><span class="line">matrix[x][y] = mun;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过x0、y0检测右上的是否已经填入数字</span></span><br><span class="line"><span class="keyword">int</span> x0 = x;</span><br><span class="line"><span class="keyword">int</span> y0 = y;</span><br><span class="line">x0--;</span><br><span class="line">y0++;</span><br><span class="line"><span class="comment">//超界处理</span></span><br><span class="line"><span class="keyword">if</span> (x0 &lt; <span class="number">0</span>)</span><br><span class="line">x0 += n;</span><br><span class="line"><span class="keyword">if</span> (y0 == n)</span><br><span class="line">y0 = n - y0;</span><br><span class="line"><span class="keyword">if</span> (!matrix[x0][y0])</span><br><span class="line">&#123;</span><br><span class="line">x = x0;</span><br><span class="line">y = y0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若有数字填入之前数字的下方</span></span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span> (x == n) x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">mun++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成双偶幻方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDoubleEvenMagicSqure</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//从1到n的平方依次赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">matrix[i][j] = num++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小正方形的对角线上的数字取其补数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(i - j) % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">4</span>; k++)</span><br><span class="line">matrix[i + k][j + k] = <span class="built_in">abs</span>(n * n + <span class="number">1</span> - matrix[i + k][j + k]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">3</span> &amp;&amp; (i + j) % <span class="number">4</span> == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">4</span>; k++)</span><br><span class="line">matrix[i - k][j + k] = <span class="built_in">abs</span>(n * n + <span class="number">1</span> - matrix[i - k][j + k]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成单偶幻方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateSingleEvenMagicSqure</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = n / <span class="number">2</span>;</span><br><span class="line">CreateOddMagicSquare(k);</span><br><span class="line"><span class="comment">//赋初值，左上最小，右下其次，右上再次，左下最大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">&#123;</span><br><span class="line">matrix[i + k][j + k] = matrix[i][j] + k * k;</span><br><span class="line">matrix[i][j + k] = matrix[i][j] + k * k * <span class="number">2</span>;</span><br><span class="line">matrix[i + k][j] = matrix[i][j] + k * k * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公式 n=4m+2 </span></span><br><span class="line"><span class="keyword">int</span> m = (n - <span class="number">2</span>) / <span class="number">4</span>;</span><br><span class="line"><span class="comment">//交换x方向正中行的从左至右m-1个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> buf = matrix[k / <span class="number">2</span>][i];</span><br><span class="line">matrix[k / <span class="number">2</span>][i] = matrix[k / <span class="number">2</span> + k][i];</span><br><span class="line">matrix[k / <span class="number">2</span> + k][i] = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> buf = matrix[k / <span class="number">2</span>][k / <span class="number">2</span>];</span><br><span class="line"><span class="comment">//以及正中间的数</span></span><br><span class="line">matrix[k / <span class="number">2</span>][k / <span class="number">2</span>] = matrix[k / <span class="number">2</span> + k][k / <span class="number">2</span>];</span><br><span class="line">matrix[k / <span class="number">2</span> + k][k / <span class="number">2</span>] = buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换除x正中间行的其他行对应数字m个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j&lt;k / <span class="number">2</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != k / <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> buf = matrix[i][j];</span><br><span class="line">matrix[i][j] = matrix[i + k][j];</span><br><span class="line">matrix[i + k][j] = buf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换最右边m-1个数字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; n - <span class="number">1</span> - (m - <span class="number">1</span>); j--)</span><br><span class="line">swap(matrix[i][j], matrix[i + k][j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = (n*(n*n + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> SumA = <span class="number">0</span>, SumB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">SumA += matrix[i][j];</span><br><span class="line"><span class="keyword">if</span> (SumA != sum)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">SumA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">SumA += matrix[j][i];</span><br><span class="line"><span class="keyword">if</span> (SumA != sum)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">SumA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">SumA += matrix[i][i];</span><br><span class="line">SumB += matrix[i][n - i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (SumA != sum || SumB != sum)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">CreateOddMagicSquare(n);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">CreateDoubleEvenMagicSqure(n);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">CreateSingleEvenMagicSqure(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; matrix[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Check(n))</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to generate!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">getchar(), getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 无聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math theory </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ 1059」 [ZJOI2007]矩阵游戏</title>
      <link href="/2018/03/06/%E3%80%8CBZOJ%201059%E3%80%8D%5BZJOI2007%5D%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/03/06/%E3%80%8CBZOJ%201059%E3%80%8D%5BZJOI2007%5D%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<h1 id="BZOJ-1059-ZJOI2007-矩阵游戏"><a href="#BZOJ-1059-ZJOI2007-矩阵游戏" class="headerlink" title="BZOJ 1059 [ZJOI2007]矩阵游戏"></a>BZOJ 1059 [ZJOI2007]矩阵游戏</h1><p>这题什么鬼。。<br>第一反应：大暴力？<br>(您的电脑怕不是128位量子计算机哦)<br><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1059" target="_blank" rel="noopener">原题传送门</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>Description</strong><br>　小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏——矩阵游戏。矩阵游戏在一个$N*N$黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作：选择矩阵的任意行列，交换这两列（即交换对应格子的颜色）游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程序来判断这些关卡是否有解。</p><p><strong>Input</strong><br>第一行包含一个整数$T$，表示数据的组数。接下来包含$T$组数据，每组数据第一行为一个整数$N$，表示方阵的大<br>小；接下来$N$行为一个$N*N$的$01$矩阵（$0$表示白色，$1$表示黑色）。</p><p><strong>Output</strong><br>输出文件应包含$T$行。对于每一组数据，如果该关卡有解，输出一行$Yes$；否则输出一行$No$。</p><p><strong>Sample Input</strong><br>2<br>2<br>0 0<br>0 1<br>3<br>0 0 1<br>0 1 0<br>1 0 0</p><p><strong>Sample Output</strong><br>No<br>Yes</p><p><strong>HINT</strong></p><p>「数据规模」<br>对于$20%$的数据，$N ≤ 7$<br>对于$50%$的数据，$N ≤ 50$<br>对于$100%$的数据，$N ≤ 200$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>emmm</p><ul><li>其实答案就是让你求是否可以找出n个点使得两两不同行且两两不同列</li><li>这点非常重要</li><li>想到了之后 恍然大悟</li><li>哦，原来只要把<strong>所有行看成左边n个点，所有列看成右边n个点，如果(i,j)是黑边就把左边第i个点与右边第j个点连边</strong>就可以了！</li><li>用vector模拟邻接链表的做法，和匈牙利算法搭配，时间复杂度为$O(nm)$</li></ul><p>下面贴出AC源码，这次貌似没什么好解释的<del>（主要是因为懒）</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 210</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> mate[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = G[x][i];</span><br><span class="line"><span class="keyword">if</span> (!vis[k])</span><br><span class="line">&#123;</span><br><span class="line">vis[k] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!mate[k] || dfs(mate[k]))</span><br><span class="line">&#123;</span><br><span class="line">mate[k] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(mate, <span class="number">0</span>, <span class="keyword">sizeof</span> mate);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">G[i].clear();<span class="comment">//一定要有这一句，爱写vector的小朋友们注意了。。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) G[i].push_back(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">if</span> (!dfs(i))</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BZOJ </tag>
            
            <tag> 匈牙利算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 省队 </tag>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ 2818」 GCD</title>
      <link href="/2018/03/05/%E3%80%8CBZOJ%202818%E3%80%8D%20GCD/"/>
      <url>/2018/03/05/%E3%80%8CBZOJ%202818%E3%80%8D%20GCD/</url>
      <content type="html"><![CDATA[<h1 id="BZOJ-2818-GCD"><a href="#BZOJ-2818-GCD" class="headerlink" title="BZOJ 2818 GCD"></a>BZOJ 2818 GCD</h1><p>咋一看这题目名字怎么那么亲切，结果看到题面就觉得不亲切了（大雾）<br><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2818" target="_blank" rel="noopener">原题传送门</a><br><strong>Description</strong><br>给定整数$N$，求$1&lt;=x,y&lt;=N$且$gcd(x,y)$为素数的数对$(x,y)$有多少对.</p><p><strong>Input</strong><br>一个整数$N$</p><p><strong>Output</strong><br>如题</p><p><strong>Sample Input</strong><br>4</p><p><strong>Sample Output</strong><br>4</p><p><strong>HINT</strong><br>对于样例$(2,2),(2,4),(3,3),(4,2)$</p><p>$1&lt;=N&lt;=10^7$</p><p>按照<del>网上流传</del>的说法，此题为欧拉函数练手题<br>解法确实也很好懂，下面做一下详细的解释：</p><p>首先，定义集合$P=\{x|x为素数\}$，接下来我们可以得出:</p><script type="math/tex; mode=display">∀p∈P,∃k_1,k_2满足gcd(k1,k2) = 1,gcd(k1·p,k2·p) = p</script><p>①若$k_1≠k_2$<br>令$k_1&gt;k_2$<br>则满足调节的$k_1$的个数就为$φ(k_1)$<br>∴$k_1,k_2$所构成的组合的个数为$2·φ(k_1)$<br>②若$k_1=k_2$<br>当且仅当$k_1=k_2=1$时，满足条件</p><p>综上，满足条件的所有数对个数为$\Sigma_{p∈P}^{n}[(\Sigma_{i=1}^{\lfloor\frac{n}{p}\rfloor}2φ(i))+1]$</p><p>推到这一步，我们会惊讶地发现<br>woc这时间复杂度已经爆表了啊。。<br>没事，我们来看看哪里爆了。。。<br>诶？似乎没爆？</p><p>==&gt;睁大眼睛好好看看$φ(N)$的计算公式：<br><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D153/sign=6ffd676c08b30f24319ae806fb94d192/8ad4b31c8701a18b93a2de42992f07082838fe76.jpg" alt=""><br>时间复杂度为标准的$O(n\sqrt{n})$，完美超时<br>下面介绍3个很奇妙的东西</p><ul><li>当$p∈P$(也就是P为质数)时，$φ(p) = p-1$</li><li>若$i\ mod\ p =\ 0$, 那么$φ(i·p)=p·φ(i)$</li><li>若$i\ mod\ p ≠\ 0$, 那么$φ(i·p)=φ(i)·( p-1 )$</li></ul><p>这些都是欧拉函数的一些很奇妙的性质（证明就不管它了）<br>利用这些性质，我们就可以在$O(n)$内搞出所有$φ$值了<br>算完了$φ$值，会发现还有一个和要维护，不然还是会T。这个简单，前缀和即可。<br>总时间复杂度$O(n)$<br>下面给出了带有<del>详细</del>注释的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000000 + 5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Phi[MAXN], p[MAXN], pt;</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getphi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pt = <span class="number">0</span>;</span><br><span class="line">Phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!flag[i])<span class="comment">//这表明了i是素数 </span></span><br><span class="line">&#123;</span><br><span class="line">p[++pt] = i;</span><br><span class="line">Phi[i] = i - <span class="number">1</span>;<span class="comment">//如果i是素数，那么phi(i) = p - 1; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pt &amp;&amp; p[j] * i &lt;= N; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = p[j] * i;</span><br><span class="line">flag[k] = <span class="literal">true</span>;<span class="comment">//k可以通过乘积的形式得到，当然就不是素数了。于是标记改为true </span></span><br><span class="line"><span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Phi[k] = p[j] * Phi[i];<span class="comment">//如果i mod p = 0, 那么 phi(i * p) = p * phi(i)</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Phi[k] = (p[j] - <span class="number">1</span>) * Phi[i];<span class="comment">//积性函数的性质 :若i mod p ≠0, 那么 phi(i * p)=phi(i) * (p - 1) </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">getphi();</span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + <span class="number">2</span> * Phi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pt; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ans += sum[(<span class="keyword">int</span>)(N / p[i])];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BZOJ </tag>
            
            <tag> 省队 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ 3253」 Fence Repair</title>
      <link href="/2018/02/27/%E3%80%8CPOJ%203253%E3%80%8D%20Fence%20Repair/"/>
      <url>/2018/02/27/%E3%80%8CPOJ%203253%E3%80%8D%20Fence%20Repair/</url>
      <content type="html"><![CDATA[<p>英文题面不好懂。还是中文简洁：<br>给一块长木板，现要将其锯成n段，共需锯n-1次，每次锯的代价为所锯木板的长度，求最小总代价。</p><p>弄个优先队列完事。。（STL大法好<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">q.push(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (q.size() &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l1, l2;</span><br><span class="line">l1 = q.top(), q.pop();</span><br><span class="line">l2 = q.top(), q.pop();</span><br><span class="line">ans += l1 + l2;</span><br><span class="line">q.push(l1 + l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ 2159」 Ancient Cipher</title>
      <link href="/2018/02/27/%E3%80%8CPOJ%202159%E3%80%8D%20Ancient%20Cipher/"/>
      <url>/2018/02/27/%E3%80%8CPOJ%202159%E3%80%8D%20Ancient%20Cipher/</url>
      <content type="html"><![CDATA[<p>这题简直太水了吧。。<br>只要对每个字母出现的次数统计并排序<br>然后分别对应的字母个数相等<br>就表明一定有转换方式。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">27</span>], b[<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line"><span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[s1[i] - <span class="string">'A'</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">b[s2[i] - <span class="string">'A'</span>]++; </span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + <span class="number">26</span>);</span><br><span class="line">sort(b, b + <span class="number">26</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
            <tag> POJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数基础 3</title>
      <link href="/2018/02/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%803/"/>
      <url>/2018/02/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%803/</url>
      <content type="html"><![CDATA[<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><blockquote><p>有趣有趣</p></blockquote><h2 id="几何含义"><a href="#几何含义" class="headerlink" title="几何含义"></a>几何含义</h2><p>平面六面体的有向体积，平行四边形的有向面积</p><h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><p>定义：完全展开式</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>决定性质:<br>1.反对称:任意两行相同时为0<br>2.双线性:行线性（列线性与行线性推导相同）<br>3.单位矩阵 ==&gt; 行列式为1</strong></p><p>==展开式能反映性质，性质最终能推出展开式==</p><p>其它性质：<br>①行列式$A$中某行(或列)用同一数$k$乘,其结果等于$kA$。<br>②行列式$A$等于其转置行列式$AT$($AT$的第$i$行为$A$的第$i$列)。<br>③若$n$阶行列式 $α$ 中某行(或列);行列式则 $α$ 是两个行列式的和,这两个行列式的第$i$行(或列),一个是$b_1,b_2,…,b_n$；另一个是$с_1，с_2,…,с_n$;其余各行（或列）上的元与 $α$ 的完全一样。<br>④行列式$A$中两行（或列）互换,其结果等于$-A$。<br>⑤把行列式$A$的某行（或列）中各元同乘一数后加到另一行（或列）中各对应元上，结果仍然是$A$。</p><h2 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h2><p>emmm很重要哦xDDDD</p><ul><li>$T(π)$表示<strong>逆序对数</strong>(<a href="https://zh.wikipedia.org/wiki/%E9%80%86%E5%BA%8F%E5%AF%B9" target="_blank" rel="noopener">什么是逆序对？</a>)</li></ul><h2 id="具体计算"><a href="#具体计算" class="headerlink" title="具体计算"></a>具体计算</h2><p>最简单的方法是按照定义<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c37d3280bcfc7714d2f4422eaea2f7628151dcc8" alt=""><br>计算或按照拉普拉斯公式进行<strong>递归</strong>运算。这样的算法需要计算$n!$次的加法，复杂度是指数函数。在实际的计算中只能用于计算阶数很小的行列式。注意到拉普拉斯公式的性质，如果一行或一列里面有很多个0，那么就可以把行列式按这一行或一列展开，这时数值为零的系数所对应的代数余子式就不必计算了，因为最后要乘以0，这样就可以简化计算。然而<strong>更加简便的算法是利用<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95" target="_blank" rel="noopener">Gauss消元法</a>或<a href="https://zh.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">LU分解法</a>，把矩阵通过初等变换变成三角矩阵或三角矩阵的乘积来计算行列式的值</strong>。这些算法的复杂度都是$n^{3}$级别，远远小于直接计算的复杂度。</p><ul><li>不满秩时行列式为$0$</li></ul>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math theory </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>矩阵的秩细细讲</title>
      <link href="/2018/02/23/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9%E7%BB%86%E7%BB%86%E8%AE%B2/"/>
      <url>/2018/02/23/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9%E7%BB%86%E7%BB%86%E8%AE%B2/</url>
      <content type="html"><![CDATA[<p>在线性代数中，一个矩阵$A$的列秩是$A$的线性独立的纵列的极大数目。类似地，行秩是$A$的线性独立的横行的极大数目。</p><p>矩阵的列秩和行秩总是<strong>相等</strong>的，因此它们可以简单地称作矩阵$A$的秩。通常表示为$r(A)$，$rk(A)$或$rank A$。</p><h1 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h1><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>奇异值分解（singular value decomposition）是线性代数中一种重要的矩阵分解，在信号处理、统计学等领域有重要应用</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>假设$ M $是一个$ m×n $阶矩阵，其中的元素全部属于域$ K $，也就是实数域或复数域。如此则存在一个分解使得$M=U\Sigma V^*$<br>其中$ U $是$ m×m $阶酉矩阵；$Σ$是$ m×n $阶非负实数对角矩阵；而$ V^* $，即$ V $的共轭转置，是$ n×n $阶酉矩阵。这样的分解就称作$ M $的奇异值分解。$ Σ $对角线上的元素$ Σ_i $， $ i $即为$ M $的奇异值。<br>常见的做法是将奇异值由大而小排列。如此$ Σ $便能由$M$唯一确定了。（$ U $和$ V $仍然不能确定）</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>观察一个$4×5$的矩阵<br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dadc0b09a06ed4cc8af20f64599c13b7d0c7481e" alt=""><br>$M$矩阵的奇异值分解如下$U\Sigma V^*$<br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b83098d6ad99cd44041aaece6be9206217d32216" alt=""><br><img src="http://i2.bvimg.com/633215/f66dd98c7e433dc5.png" alt=""></p><h1 id="正式内容"><a href="#正式内容" class="headerlink" title="正式内容"></a>正式内容</h1><h2 id="行秩列秩相等性"><a href="#行秩列秩相等性" class="headerlink" title="行秩列秩相等性"></a>行秩列秩相等性</h2><p>矩阵的行秩与列秩相等，是线性代数基本定理的重要组成部分. 其基本证明思路是，矩阵可以看作<strong>线性映射的变换矩阵</strong>，列秩为<strong>像空间</strong>的维度，行秩为<strong>非零原像空间</strong>的维度，因此列秩与行秩相等，即<strong>像空间的维度</strong>与<strong>非零原像空间的维度</strong>相等（这里的非零原像空间是指约去了<strong>零空间</strong>后的<strong>商空间</strong>：<strong>原像空间</strong>）。这从矩阵的<strong>奇异值分解</strong>就可以看出来。</p><ul><li><strong>引理</strong> 设矩阵$A=a_{ij}(s×n)$的列秩等于$A$的列数$n$，则$A$的列秩，行秩都等于$n$。</li><li><strong>定理</strong> 矩阵的行秩，列秩，秩都相等。</li><li><strong>定理</strong> 初等变换不改变矩阵的秩。</li><li><strong>定理</strong> 矩阵的乘积的秩$R(ab)&lt;=min(R(a),R(b))$;<blockquote><p>当$r(A)≤n-2$时，最高阶非零子式的阶数$≤n-2$，任何$n-1$阶子式均为零，而伴随阵中的各元素就是$n-1$阶子式再加上个正负号，所以伴随阵为$0$矩阵。<br>当$r(A)≤n-1$时，最高阶非零子式的阶数$≤n-1$，所以$n-1$阶子式有可能不为零，所以伴随阵有可能非零（等号成立时伴随阵必为非零）。</p></blockquote></li></ul><h2 id="秩的变化规律"><a href="#秩的变化规律" class="headerlink" title="秩的变化规律"></a>秩的变化规律</h2><p>(1) Transpose后秩不变<br>(2) $r(A)≤min(m,n)$,$A$是$m×n$型矩阵<br>(3) $r(kA)=r(A)$,$k$不等于0<br>(4) $r(A)=0 ⇔ A=0$<br>(5) $r(A+B)≤r(A)+r(B)$<br>(6) $r(AB)≤min(r(A),r(B))$<br>(7) $r(A)+r(B)-n≤r(AB)$</p><p>就讲到这啦。。。。</p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math theory </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>显示不出来mathjax的解决方案</title>
      <link href="/2018/02/22/%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%87%BA%E6%9D%A5mathjax%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/02/22/%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%87%BA%E6%9D%A5mathjax%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>工具：chrome<br>有页面显示不出来数学公式？那是因为https不能加载http的js脚本<br>我们看到chrome的地址栏的右端有一块带叉叉的盾牌。点开，允许加载不安全的脚本即可<br>PS:我TM眼瞎看了一晚上才看到这个按钮xDDDD<br>PS:本页就引用了Mathjax, 同学们看看$\sum_{i=0}^9a_i$能不能正常显示吧！</p>]]></content>
      
      <categories>
          
          <category> 日常小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> mathjax </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数基础 2</title>
      <link href="/2018/02/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/"/>
      <url>/2018/02/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/</url>
      <content type="html"><![CDATA[<h1 id="线性方程组的一般解法："><a href="#线性方程组的一般解法：" class="headerlink" title="线性方程组的一般解法："></a>线性方程组的一般解法：</h1><p>1.Gauss消元法<br>2.特解<br>3.导出组<br>4.解系为特解+导出组</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵的基本运算"><a href="#矩阵的基本运算" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h2><h3 id="加法和数乘"><a href="#加法和数乘" class="headerlink" title="加法和数乘"></a>加法和数乘</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>例子：<br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D421/sign=0f97b8cb332ac65c63056771caf3b21d/e61190ef76c6a7effb0bcc8dfbfaaf51f3de666f.jpg" alt=""><br>矩阵的加法满足下列运算律(A，B，C都是同型矩阵)：<br>也就是：<br>$ A+B=B+A $<br>$ (A+B)+C=A+(B+C) $</p><p>矩阵的加法其实和数的加法没啥区别</p><p><strong>Tips:</strong></p><ul><li>矩阵加法满足交换律、结合律</li><li>只有同型矩阵之间才可以进行加法</li></ul><p>减法和加法差不多，把符号变一下就好了</p><h4 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h4><p>例子：<br><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D414/sign=6f0ce0878101a18bf4eb134eaa2e0761/21a4462309f790527cfa21950af3d7ca7acbd5b0.jpg" alt=""><br>矩阵的数乘满足如下运算律：<br><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D104/sign=907e8cfad6160924d825a61be006359b/a8773912b31bb051de9a5884307adab44bede0e4.jpg" alt=""><br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D135/sign=639077708c13632711edc630a48ea056/2934349b033b5bb5bba5cb5230d3d539b600bc28.jpg" alt=""><br><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D136/sign=e2c500c8504e9258a23482edaa83d1d1/c2fdfc039245d6883fd95a08a2c27d1ed31b2447.jpg" alt=""></p><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>对于两个矩阵 $ A, B $<br>必须满足$A$的列数和$B$的行数相同，才可以相乘<br>矩阵乘法不满足交换律</p><blockquote><p>等你读了数学系你会发现现代数学中定义的大多数运算都是不满足交换律的，交换律实在是个非常强大的东西</p></blockquote><p>若$A$是$m×n$矩阵和$B$是$n×p$矩阵，它们的乘积$C$是一个$m×p$矩阵<br>那么对于它的一个元素$ C_{i,j} $<br><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D336/sign=11b179be740e0cf3a4f748f83c47f23d/9213b07eca8065388d3470bf91dda144ac348244.jpg" alt=""></p><p>简而言之，就是A得第i行与B得第j列逐个相乘得和，得$ C_{i,j} $<br>这也就是为什么矩阵乘法是这样定义的（我好像把因果搞反了23333）</p><ul><li>矩阵乘法满足结合律</li></ul><h3 id="矩阵的运算与秩的关系"><a href="#矩阵的运算与秩的关系" class="headerlink" title="矩阵的运算与秩的关系"></a>矩阵的运算与秩的关系</h3><p>用$r(A)$表示矩阵的秩<br>$r(AB)≤min(r(A),r(B))$<br>$r(A+B)≤r(A)+r(B)$<br>$Sylvester不等式：r(AB)≥r(A)+r(B)-n，其中A为x×n的矩阵, B为n×k的矩阵$</p><h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><p>理解：就是<strong>行列互换</strong><br>例子:<br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D168/sign=934ec88dfbfaaf5180e385b9b45594ed/960a304e251f95ca8c9df21dcf177f3e67095234.jpg" alt=""></p><p>Tips:</p><script type="math/tex; mode=display">(AB)^T≠A^TB^T</script><p>这个可以用矩阵乘法去验证<br>其实</p><script type="math/tex; mode=display">(AB)^T=B^TA^T</script><p>这个也是很容易验证的</p><h2 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h2><h3 id="单位矩阵与初等矩阵"><a href="#单位矩阵与初等矩阵" class="headerlink" title="单位矩阵与初等矩阵"></a>单位矩阵与初等矩阵</h3><p>单位矩阵：对角线是1，其它元素都为0(都是nxn的矩阵)<br><strong>下文称单位矩阵为I</strong><br>满足AI=IA=A</p><h3 id="初等矩阵和初等变换"><a href="#初等矩阵和初等变换" class="headerlink" title="初等矩阵和初等变换"></a>初等矩阵和初等变换</h3><p>左乘<br>1.初等行变换：$i行×k$<br>2.$i行-j行(i,j)是-1$<br>3.$i行与j行交换$<br>右乘（与左乘相反）<br>1.初等列变换：$i行×k$<br>2.$i列-j列(i,j)是-1$<br>3.$i列与j列交换$</p><p>这与矩阵求逆是有些关系的</p><h3 id="逆矩阵-可逆矩阵-矩阵求逆：初等变换法"><a href="#逆矩阵-可逆矩阵-矩阵求逆：初等变换法" class="headerlink" title="逆矩阵(可逆矩阵)矩阵求逆：初等变换法"></a>逆矩阵(可逆矩阵)矩阵求逆：初等变换法</h3><p>初等变换<strong>可逆</strong></p><blockquote><p>现在前沿科技还在研究矩阵求逆的方法</p></blockquote><p>逆矩阵：$A$矩阵，如果能找到矩阵$B$使得$AB=I$,那么称$B$是$A$的逆<br>$BA=I$，同样$A$可逆，并且$B$是$A$的逆<br>也就是说,$如果有AB=I，那么BA一定等于I(A和B都是方阵)$。（看起来简单，证明一点都不简单）<br>满秩等价于可逆<br>$A$为$n$阶方阵<br>$r(A)=n$<br>那么$A$满秩</p><p>我们总可以做初等变换把一个矩阵$A$变成相抵标准型$D$<br>初等变换不改变秩<br>如果$A$是满秩的，它的标准型<strong>就是单位矩阵$I$</strong><br>初等行变换就是左乘若干初等矩阵<br>$I$的逆就是$I$，因为$I×I=I$</p><p>取逆:</p><script type="math/tex; mode=display">(AB)^{-1}=B^{-1}A^{-1}</script><script type="math/tex; mode=display">(ABC)^{-1}=C^{-1}(AB)^{-1}=C^{-1}B^{-1}A^{-1}</script><p>A——初等行变换—-&gt;I<br>I——初等行变换—-&gt;A</p><p><strong>不是方阵—-&gt;不满秩—-&gt;无法求逆<br>必须要方阵才可逆</strong></p><p>$[AI] (n×2n的矩阵)$<br>Gauss消元：对左边消元，对右边进行相同的操作<br>直到$A$变成$I$，那么$I$就变成了$A$的逆</p>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math theory </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何卸载hexo</title>
      <link href="/2018/02/21/%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BDhexo/"/>
      <url>/2018/02/21/%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BDhexo/</url>
      <content type="html"><![CDATA[<p>安装了hexo，出了问题，该如何卸载呢？<br>对于2.x版本的hexo,我们知道安装命令为<br><code>npm install hexo -g</code><br>那么我们只需要把install替换为uninstall即可，相应的命令为<br><code>npm uninstall hexo -g</code></p><p>对于3.x版本的hexo,我们知道安装命令为<br><code>npm install hexo-cli -g</code><br>那么我们只需要把install替换为uninstall即可，相应的命令为<br><code>npm uninstall hexo-cli -g</code></p>]]></content>
      
      <categories>
          
          <category> 日常小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数基础 1</title>
      <link href="/2018/02/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/"/>
      <url>/2018/02/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/</url>
      <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="复数的基本知识"><a href="#复数的基本知识" class="headerlink" title="复数的基本知识"></a>复数的基本知识</h2><p>形如$a+bi(a,b∈R)$的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位。当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数。复数域是实数域的代数闭包，也即任何复系数多项式在复数域中总有根。</p><h2 id="数域的概念"><a href="#数域的概念" class="headerlink" title="数域的概念"></a>数域的概念</h2><p>设$P$是由一些数组成的集合，如果$P$中任意两个数的和、差、积、商（除数不为0）仍是$P$中的数，则称$P$为一个数域。</p><ul><li>常见数域： 复数域$C$；实数域$R$；有理数域$Q$。</li><li>若数集$P$中任意两个数作某一运算的结果仍在$P$中，则说数集$P$对这个运算是封闭的。</li><li>数域的等价定义：如果一个包含0，1在内的数集$P$对于加法，减法，乘法与除法（除数不为0）是封闭的，则称数集$P$为一个数域。</li></ul><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><h2 id="什么是线性方程组"><a href="#什么是线性方程组" class="headerlink" title="什么是线性方程组?"></a>什么是线性方程组?</h2><p>线性方程组长这样:<br><img src="http://i2.bvimg.com/633215/0f549ce81e86dc1a.png" alt=""></p><p>m个方程,n个未知数<br>比较大的，比较复杂的<br>所谓线性，就是没有平方啊，立方啊，$ e^x $ 啊，$ sin^x $ 之类的东西，全部都是$ax+b$的形式</p><h2 id="那么这种线性方程组怎么解呢？"><a href="#那么这种线性方程组怎么解呢？" class="headerlink" title="那么这种线性方程组怎么解呢？"></a>那么这种线性方程组怎么解呢？</h2><p><strong>高斯消元</strong><br>首先我们要知道<br>初等行变换的三种形式<br>1) 把一行乘上若干倍（当然是非0数）<br>2) 把一行减去另一行<br>3) 把两行互换位置<br>初等变换是<strong>可逆</strong>的</p><p>也就是说<br>1) 两方程互换，解不变；<br>2) 一方程乘以非零数$k$，解不变；<br>3) 一方程乘以数$k$加上另一方程，解不变。</p><p>高斯消元就是说，可以用这三种变换，把方程组变成阶梯型（甚至不是这种形状，就是变得好看一些）<br><strong>如何做？</strong></p><p>请看如下方程：<br><img src="http://i2.bvimg.com/633215/21f112f53007cafd.png" alt=""></p><p>$x$系数相同，消去$x$，解得$z$<br>随后，$z$的系数相同，解得$y$<br>代入，解得$x$<br>方程的解为：</p><p><img src="http://i2.bvimg.com/633215/691b0993cd796f33.png" alt=""></p><p>齐次线性方程组：解空间<br>非齐次的：导出组：<br>它的解为一个<strong>线性流形</strong></p><blockquote><p><strong>线性流形是啥？</strong><br>1.开集：设$A$是开集,则对$A$中的任意一点$a$,存在$a$的邻域$o(a)⊆A$<br>2.微分同胚：若$U$、$V$是$n$维实数空间（下面记之为$R^n$）中的开集,一个从$U$到$V$的可微函数$h$,如果从$V$到$U$的可微逆,则称$h$为微分同胚.<br>3.$K$维流形：$R^n$中的子集$M$称为$K$维流形,如果对于$M$中的每一点$x$都满足以下条件：<br>存在一个含$x$的开集U、一个$R^n$中的开集$V$和一个从$U$到$V$的微分同胚$h$,使得<br>$h(U∩V)=V∩(R^k×\{0\})=\{y∈V；y^{k+1}=……=y^n=0\}$<br>4.另一种等价的定义：$R^n$中的子集$M$称为$K$维流形,当且仅当$M$中的每一个点$x$,下述条件成立：<br>存在一个包含$x$的开集$U$,一个$R^k$中的开集$W$以及一个从$W$到$R^n$的$1-1$可微函数$f$,使得：<br>1)$f(W)=M∩U$；<br>2)$f’(y)$对每个$y∈W$的秩为$k$；<br>3)从$f(W)$到$W$的$f$的逆连续.<br>上述条件叫通常叫“坐标条件”,这样的$f$叫做$x$周围的坐标系.<br>5.线性流形,即满足线性运算的流形.<br>例子：<br>1）$R^n$的一个开集<br>2）$n$维球面：$\{x∈R^{n+1}:|x|=1\}$</p></blockquote><p>方程组个数小于未知数个数时一定有解？<br>很小的时候，就听说过老师说方程组个数小于未知数个数时一定有解。不知道大家是怎么理解的。</p><p>方程组可以理解为是用来约束未知数的条件，方程组过多，约束更多，不一定有解。相反地，方程组过少，约束更少，就一定有解。</p><ul><li>真的是这样吗？<br>其实跟系数矩阵的秩有很大的关系</li></ul><h1 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>向量其实只是一个名称而已,不再代表具体的含义,只是一种形式记号</p><ul><li>和以前的$(x,y)$表示不太一样，以前表示的只是一种有方向的量。写成这样$(x_1,x_2,…,x_n)$<br>这样叫做行向量。相应地，竖着写也行。竖着写叫做列向量。</li></ul><h2 id="向量组"><a href="#向量组" class="headerlink" title="向量组"></a>向量组</h2><p>E.g.<br><img src="http://i2.bvimg.com/633215/caf1a675646fd262.png" alt=""></p><h2 id="数域上的向量组的线性相关与无关"><a href="#数域上的向量组的线性相关与无关" class="headerlink" title="数域上的向量组的线性相关与无关"></a>数域上的向量组的线性相关与无关</h2><p>我们引入了一个线性代数中相当重要的概念：<strong>线性相关</strong></p><ul><li>什么是线性相关？<br>假如存在<strong>不全为0</strong>的$k_1,k_2,…,k_n$，使得 $k_1\alpha_1+k_2\alpha_2+…+k_n\alpha_n=0$</li></ul><p>则称$k_1,k_2,…,k_n$和$\alpha_1+\alpha_2+…+\alpha_n$线性相关<br>线性：只是将一个向量乘一个常数，并没有一个向量乘一个向量<br>可以通过线性运算整合到一起</p><p>那么<br><img src="http://i2.bvimg.com/633215/caf1a675646fd262.png" alt=""><br>是否线性相关？</p><p>这个例子啊，本身判断线性相关或无关其实很困难<br>但是我们看到<br>$\alpha_1+\alpha_2-4\alpha_3=0$<br>也就是说$\alpha_3$可以用$\alpha_1和\alpha_2$表示<br><strong>这个结论很重要，请牢记</strong></p><h2 id="向量组的秩-rank"><a href="#向量组的秩-rank" class="headerlink" title="向量组的秩(rank)"></a>向量组的秩(rank)</h2><p>平时大家都喜欢rank1,rank2，但在这里，rank是秩序的意思QwQ</p><h3 id="极大线性无关组"><a href="#极大线性无关组" class="headerlink" title="极大线性无关组"></a>极大线性无关组</h3><p>线性无关组：线性无关的向量组成的向量组<br>极大线性无关组：一个不能再向里面添加任何其他向量的线性无关组（添加之后就线性有关了）</p><ul><li><p>怎么构造？<br>$\alpha_1,\alpha_2,…\alpha_n$<br>对于每个向量，和之前的向量检验相关性即可<br>虽然检验是否有关的时间复杂度很可怕（误），但这个算法表面上看来是$O(n)$的<br>向量组可以由它表出</p></li><li><p>什么是表出？<br>设$α_1,α_2,…,α_e(e≥1)$是域P上线性空间V中的有限个向量，若V中向量α可以表示为$α=k_1α_1+k_2α_2++…k_eα_e(k_a∈P，a=1,2,…,e)$，则称α是向量组$α_1,α_2,…,α_e(e≥1)$的一个线性组合，亦称α可由向量组$α_1,α_2,…,α_e(e≥1)$线性表示或线性表出。</p></li></ul>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math theory </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求凸多边形的面积</title>
      <link href="/2018/02/07/%E8%AE%A1%E7%AE%97%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/"/>
      <url>/2018/02/07/%E8%AE%A1%E7%AE%97%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="求凸多边形的面积（pol）"><a href="#求凸多边形的面积（pol）" class="headerlink" title="求凸多边形的面积（pol）"></a>求凸多边形的面积（pol）</h2><p><strong>问题描述</strong>：<br>按一定的顺序（顺、逆时针）给出一个多边形的各顶点坐标，求该多边形的面积。<br><strong>输入</strong>：<br>第一行包含一个n，表示多边形顶点的个数( 0&lt;=n&lt;=100)<br>第2行到第n+1行，每行两个整数x，y（-10000&lt;=x，y &lt;= 10000）<br><strong>输出</strong>：<br>    输出有且只有一行，包含一个数s，s为多边形的面积，保留一位小数<br><strong>样例</strong>：<br>pol.in<br>3<br>0 0<br>0 3<br>3 0</p><p>pol.out<br>4.5<br>题目及测试数据: <a href="https://github.com/Leoleepz/OI-Codes/tree/master/%E4%BB%BB%E6%84%8F%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF" target="_blank" rel="noopener">https://github.com/Leoleepz/OI-Codes/tree/master/%E4%BB%BB%E6%84%8F%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF</a></p><ul><li>第一种方法即为朴素的向量方法。我们可以把凸多边形拆成多个三角形的面积去做。我们会发现，如果用原点去构造三角形来操作，最终结果就是（逆时针坐标乘积-顺时针坐标乘积）÷2.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ComputeTriangleVectorArea CTVA</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;Point&gt; Points;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ComputeTriangleVectorArea</span><span class="params">(Point p1, Point p2, Point p3)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)<span class="number">0.5</span> * ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y));   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Compute</span><span class="params">(<span class="built_in">vector</span> &lt;Point&gt; PointSet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (PointSet.empty()) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> area = <span class="number">0.0</span>;</span><br><span class="line">Point O;</span><br><span class="line">O.x = O.y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="built_in">vector</span>&lt;Point&gt;::iterator ii = PointSet.begin(); ii != PointSet.end() - <span class="number">1</span>; ++ii)</span><br><span class="line">&#123;</span><br><span class="line">area += CTVA(O,(*ii),(*(ii + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">area += CTVA(O,PointSet[PointSet.size() - <span class="number">1</span>], PointSet[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(area);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"pol.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"pol.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">Point tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp.x &gt;&gt; tmp.y;</span><br><span class="line">Points.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%0.1lf\n"</span>,Compute(Points));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种方法我脑洞了一下，用了定积分的方法。定积分有正有负，依次求和，重复部分由于正负会相互抵消，最后剩下的总面积的绝对值就是多边形的面积。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;Point&gt; Points;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">LinearIntegration</span><span class="params">(Point p1, Point p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)<span class="number">0.5</span> * (p2.x - p1.x) * (p2.y + p1.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">ComputeArea</span><span class="params">(<span class="built_in">vector</span> &lt;Point&gt; PointSet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (PointSet.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="built_in">vector</span>&lt;Point&gt;::iterator ii = PointSet.begin(); ii != PointSet.end() - <span class="number">1</span>; ++ii)</span><br><span class="line">&#123;</span><br><span class="line">area += LinearIntegration((*ii),(*(ii + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">area += LinearIntegration(PointSet[PointSet.size() - <span class="number">1</span>], PointSet[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(area);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"pol.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"pol.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">Point tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp.x &gt;&gt; tmp.y;</span><br><span class="line">Points.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%0.1lf\n"</span>,ComputeArea(Points));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math theory </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>米勒-拉宾素数判定 MR Prime Detect</title>
      <link href="/2018/02/05/%E7%B1%B3%E5%8B%92%E6%8B%89%E5%AE%BE%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A%20MR%20Prime%20Detect/"/>
      <url>/2018/02/05/%E7%B1%B3%E5%8B%92%E6%8B%89%E5%AE%BE%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A%20MR%20Prime%20Detect/</url>
      <content type="html"><![CDATA[<h1 id="首先需要知道两个定理"><a href="#首先需要知道两个定理" class="headerlink" title="首先需要知道两个定理:"></a>首先需要知道两个定理:</h1><p>1、<strong>费马小定理</strong>： 假如p是素数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p）。不知所云的萌新请点击此处‍自行脑补一下</p><p>2、<strong>二次探测定理</strong>：如果p是素数，x是小于p的正整数，且 ，那么要么x=1，要么x=p-1。</p><p>　　证明：这是显然的，因为 相当于p能整除 ，也即p能整除(x+1)(x-1)。</p><p>　　由于p是素数，那么只可能是x-1能被p整除(此时x=1) 或 x+1能被p整除(此时x=p-1)。</p><p>接着，如果a^(n-1) ≡ 1 (mod n)成立，Miller-Rabin算法不是立即找另一个a进行测试，而是看n-1是不是偶数。如果n-1是偶数，另u=(n-1)/2，并检查是否满足二次探测定理即a^u ≡ 1 或 a^u ≡ n - 1(mod n)。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>Miller-Rabin算法随机生成底数a，进行多次调用函数进行测试，Miller-Rabin检测也存在伪素数的问题，但是与费马检测不同，MR检测的正确概率不依赖被检测数p，而仅依赖于检测次数。已经证明，如果一个数p为合数，那么Miller-Rabin检测的证据数量不少于比其小的正整数的3/4，换言之，k次检测后得到错误结果的概率为(1/4)^k。我们在实际应用中一般可以测试15~20次。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, buff = a;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)ans = (ans * buff) % r;</span><br><span class="line">buff = (buff * buff) % r;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabbin</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, s = n - <span class="number">1</span>, j;</span><br><span class="line"><span class="keyword">if</span> (!(n%a))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!(s &amp; <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k = qpow(a, s, n);</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; r; j++, k = k * k % n)</span><br><span class="line"><span class="keyword">if</span> (k == n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tab[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == tab[i])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!Miller_Rabbin(n, tab[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; IsPrime(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math theory </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
